<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>ifunny_lib API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ifunny_lib</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This is the library that will deal with interfacing with the Ifunny servers to pull info
import os
import hashlib
import base64
import requests
import json
from lxml import html
from pprint import pprint
import logging
import datetime
import time
import pickle
import copy

&#34;&#34;&#34;
I am trying to avoid putting too many parameters in functions. As such I have tried to take a more init object and then
load parts approach. I also put effort to avoid spamming the servers with requests. Also some of the recursive things 
could be slow and may be reworked, but unlikely unless it is crippling.
Made by Nam. Discord: that_dude#1313, Github: XDEmer0r-L0rd-360-G0d-SlayerXD
&#34;&#34;&#34;

logger = logging.getLogger(__name__)
logger.setLevel(logging.WARNING)

# basic token needs to be set for most commands, bearer is for things that need a login
# these need to be changed. Use load_auths() to do so
# Things will go wrong if you don&#39;t.
BASIC_TOKEN = &#34;&#34;
BEARER_TOKEN = &#34;&#34;


class MissingAuthToken(Exception):
    &#34;&#34;&#34;
    Exists only to tell the user that load_auths() has not been run.
    &#34;&#34;&#34;


class NoContent(Exception):
    &#34;&#34;&#34;
    There was an error when searching for the content and the api returned an error.
    &#34;&#34;&#34;


class Queue:
    &#34;&#34;&#34;
    This is to store queues such as post a user has, replies a post has, etc.
    not all list functions are implemented. If not, use it on Queue.stored_content as that is the basis.
    &#34;&#34;&#34;

    def __init__(self, stored_class_type: type = None, source_url: str = None, tag_only_mode: str = None):
        &#34;&#34;&#34;
        The init method which prepares the class. The auth needs to be changed from outside if it doesn&#39;t use basic.
        :param stored_class_type: What Type of object that is going to be stored such as User, Post, Comment.
        :param source_url: What endpoint is going to be used.
        :param tag_only_mode: If given, it will only store that attribute from the data in the list
        :param force_load: force load from id to ensure consistency of content. May lose or gain data.
        &#34;&#34;&#34;
        # todo maybe make this inheret from list to give more functionality via __*__

        logger.info(&#34;Queue object created&#34;)

        if source_url is None:
            raise ValueError(&#34;Missing arg&#34;)
        self.stored_class_type = stored_class_type
        self.source_url = source_url
        self.tag_only_mode = tag_only_mode  # setting this to false before loading anything will may decrease server load and avoid making mare object
        self.stored_content = []  # this is just a list of the objects Queue just makes loading them easier
        self.page_next = None
        self.has_next = True
        self.chunks = 100  # this can be changed as an option but is set to max size for max speed
        self.auth_token = BASIC_TOKEN

    def __iter__(self):
        return (t for t in self.stored_content)

    def __getitem__(self, item):
        return self.stored_content[item]

    def __len__(self):
        return len(self.stored_content)

    def __str__(self):
        return str(self.stored_content)

    def store(self, thing):
        &#34;&#34;&#34;
        A single word way to store a piece of data.
        &#34;&#34;&#34;
        self.stored_content.append(thing)
        return self

    def clear(self):
        &#34;&#34;&#34;
        This resets the stored content if called for any reason.
        &#34;&#34;&#34;
        self.stored_content = []
        self.page_next = None
        self.has_next = True
        return self

    def queue_data_cleaner(self, var):
        &#34;&#34;&#34;
        Hopefully a universal data cleaner that strips unwanted data.
        &#34;&#34;&#34;
        # this returns a cleaned dict after striping the output it deems unneeded and should return a list
        # this one was made for posts nad needs to be calibrated
        if type(var) == list:
            if len(var) &gt; 0 and &#34;guest&#34; in var[0]:
                return [a[&#39;guest&#39;] for a in var]
            return var
        elif type(var) == dict:
            if &#34;items&#34; in var:
                return self.queue_data_cleaner(var[&#34;items&#34;])
            elif &#34;comments&#34; in var:
                return self.queue_data_cleaner(var[&#34;comments&#34;])
            elif &#34;replies&#34; in var:
                return self.queue_data_cleaner(var[&#34;replies&#34;])
            elif &#34;content&#34; in var:
                return self.queue_data_cleaner(var[&#34;content&#34;])
            elif &#34;data&#34; in var:
                return self.queue_data_cleaner(var[&#34;data&#34;])
            elif &#34;id&#34; in var:
                return [var]
            elif &#34;users&#34; in var:
                return self.queue_data_cleaner(var[&#34;users&#34;])
            elif &#34;guests&#34; in var:
                return self.queue_data_cleaner(var[&#39;guests&#39;])
        pprint(var)
        pprint(self.source_url)
        raise KeyError(&#34;failed to find key&#34;)

    def page_info(self, var):
        if type(var) != dict:
            return
        if &#34;paging&#34; in var:
            return var[&#34;paging&#34;]
        else:
            for k in var.keys():
                found = self.page_info(var[k])
                if found:
                    return found
        raise KeyError(&#34;No &#39;paging&#39; key found&#34;)

    def load(self, limit: int = None, paging_start: str = None):
        &#34;&#34;&#34;
        I want to do this in chunks of 100 so we get data as fast as possible. When limit == None we load until no more
        if limit == 0 then we return a clean Queue object.
        force_load does nothing right now, am considering giving the option to recall all obects by id to ensure all data is stored
        :param limit: How many to load
        :param paging_start: Changes the loading start point
        :return: self
        &#34;&#34;&#34;
        if limit == 0:
            # dumb shit may possible here without the check
            return

        if self.source_url == &#34;https://api.ifunny.mobi/v4/users/my/guests&#34;:
            limit += 1

        while self.has_next:
            if not limit or limit &gt; self.chunks:
                response = api_call(self.source_url, auth=self.auth_token, params={&#39;next&#39;: paging_start, &#39;limit&#39;: self.chunks}, method=&#34;GET&#34; if self.source_url != &#34;https://api.ifunny.mobi/v4/feeds/collective&#34; else &#34;POST&#34;)
            #     do parse and store
            else:
                response = api_call(self.source_url, auth=self.auth_token, params={&#39;next&#39;: paging_start, &#39;limit&#39;: limit})
            # pprint(response)
            pure_list = self.queue_data_cleaner(response)
            if self.tag_only_mode:
                for a in pure_list:
                    self.store(a[self.tag_only_mode])
            elif self.stored_class_type is None:
                for a in pure_list:
                    self.store(a)
            elif self.stored_class_type == Post:
                for a in pure_list:
                    self.store(Post(data=a))
            elif self.stored_class_type == Comment:
                for a in pure_list:
                    self.store(Comment(data=a))
            elif self.stored_class_type == Reply:
                for a in pure_list:
                    self.store(Reply(data=a))
            elif self.stored_class_type == User:
                for a in pure_list:
                    self.store(User(data=a))
            else:
                raise TypeError(&#34;type was not found&#34;)
            page_info = self.page_info(response)
            self.has_next = page_info[&#39;hasNext&#39;]
            # print(page_info)
            if self.has_next:
                paging_start = self.page_next = page_info[&#34;cursors&#34;][&#39;next&#39;]
            if limit:
                limit -= self.chunks
                if limit &lt;= 0:
                    return self

    def load_next(self, limit: int = 1):
        &#34;&#34;&#34;
        load the next posts after the current loaded ones
        limit == None will load until end,
        :param limit:
        :return: self
        &#34;&#34;&#34;
        self.load(limit, self.page_next)
        return self

    def load_until(self, ids: tuple = (), needed_matches: int = 1, include_matches: bool = True, emergency_limit: int = -1, clean_overflow: bool = True):
        &#34;&#34;&#34;
        This will load objects until enough matching id&#39;s are found. Ideally for loading until old content in found.
        &#34;&#34;&#34;
        pointer = 0  # shows what we are looking at in stored_content
        while needed_matches &gt; 0 and emergency_limit != 0:
            self.load_next(limit=self.chunks)
            for a in self.stored_content[pointer:]:
                if a.id in ids:
                    needed_matches -= 1
                    if not include_matches:
                        self.stored_content.remove(pointer)
                        pointer -= 1
                pointer += 1
            emergency_limit -= 1
        if clean_overflow:
            self.stored_content = self.stored_content[:min(pointer + 1, len(self.stored_content))]
        return self

    def save_to_file(self, file_name: str = None):
        if not file_name:
            file_name = str(self.stored_class_type).replace(&#34;&#39;&#34;, &#39;&#39;).replace(&#39;class&#39;, &#39;&#39;).replace(&#39; &#39;, &#39;&#39;).replace(&#39;ifunny_lib.&#39;, &#39;&#39;).replace(&#39;&lt;&#39;, &#39;&#39;).replace(&#39;&gt;&#39;, &#39;&#39;) + &#34;_queue&#34;
        if &#39;.txt&#39; not in file_name:
            file_name += &#39;.txt&#39;
        with open(file_name, &#39;w&#39;) as f:
            for a in self.stored_content:
                if type(a) == str:
                    f.write(a + &#39;\n&#39;)
                else:
                    f.write(str(a.cdata) + &#39;\n&#39;)

    def load_from_file(self, file_name: str):
        with open(file_name, &#39;r&#39;) as f:
            for a in f.readlines():
                self.store(self.stored_class_type(data=eval(a.strip())))


class IfBase:

    def __init__(self, file_name: str = None):
        try:
            self.cdata = self.__getattribute__(&#34;cdata&#34;)
        except AttributeError:
            self.cdata = {}

        self.errored_attributes = set()
        self.data_attributes = [&#34;cdata&#34;, &#39;errored_attributes&#39;]
        if not file_name:
            self.file_name = str(datetime.datetime.now().strftime(&#34;%Y%m%d-%H%M%S&#34;))
        else:
            self.file_name = str(file_name)
        # print(type(str(self.file_name)))

    def store_file_full(self, name: str = None):
        &#34;&#34;&#34;Uses alternative method to store all of object data. Maybe works a panic option.
        :param name: File name/path to open
        &#34;&#34;&#34;
        if not name:
            name = self.file_name
        with open(name, &#39;wb&#39;) as f:
            pickle.dump(self, f)
        logger.debug(&#34;Full store&#34;)

    def load_file_full(self, name: str):
        &#34;&#34;&#34;Uses alternative method to store all of object data. Maybe works a panic option.
        :param name: File name/path to open
        &#34;&#34;&#34;
        if not name:
            name = self.file_name
        with open(name, &#39;rb&#39;) as f:
            data = pickle.load(f)
            print(data.__dict__[&#39;smiles&#39;])
            self.__dict__ = copy.deepcopy(data.__dict__)
        logger.debug(&#34;Full load&#34;)

    def store_file(self, name: str = None):
        if not name:
            name = self.file_name
        with open(name, &#39;wb&#39;) as f:
            data = [self.__getattribute__(a) for a in self.data_attributes]
            pickle.dump(data, f)

    def load_file(self, name: str):
        if not name:
            name = self.file_name
        with open(name, &#34;rb&#34;) as f:
            data = pickle.load(f)
            for num_a, a in enumerate(data):
                if type(a) == Queue:
                    logger.debug(num_a, self.data_attributes[num_a], a.stored_content)
                self.__setattr__(self.data_attributes[num_a], a)

    def load_data(self, data: dict):
        &#34;&#34;&#34;
        Probably unnecessary
        &#34;&#34;&#34;
        self.cdata = data

    def try_store_attribute(self, name: str, val: str):
        &#34;&#34;&#34;
        Try to clean up the constant try-excepting
        &#34;&#34;&#34;
        try:
            self.__setattr__(name, self.cdata[val])
        except KeyError:
            self.errored_attributes.add(name)


class Comment(IfBase):
    &#34;&#34;&#34;
    This is a single comment for easier parsing
    &#34;&#34;&#34;

    def __init__(self, post_id: str = None, comment_id: str = None, data: dict = None, file_name: str = None):
        &#34;&#34;&#34;
        Args are only used to find comment, internal vars are updated on their own.
        post_id and comment_id are used to directly pull comment info
        raw_data is the entire json that holds the comment data
        cdata (cleaned data) is raw_data but stripped of the [&#39;data&#39;][&#39;comment&#39;] keys
        only need post_id &amp; comment_id or raw_data or cdata. The &#39;text&#39; tag will contain the text or link to picture
        comment, but defaults to only text if both are present.
        :param post_id: post id string
        :param comment_id: comment id string
        &#34;&#34;&#34;

        logger.info(&#34;Comment/Reply object created&#34;)

        super().__init__(file_name)
        self.data_attributes.extend((&#34;smiles&#34;, &#39;replies&#39;))

        if file_name:
            pass
        else:
            self.load_file(file_name)
        if post_id and comment_id:
            data = api_call(f&#39;https://api.ifunny.mobi/v4/content/{post_id}/comments/{comment_id}&#39;,
                            auth=BASIC_TOKEN)
            self.cdata = self._data_cleaner(data)
        elif data:
            self.cdata = self._data_cleaner(data)
        elif not any((post_id, comment_id, data, file_name)):
            raise ValueError(&#34;need args&#34;)

        self.update_attributes()

        if not file_name and &#34;id&#34; not in self.errored_attributes:
            self.file_name = self.id + &#34;_&#34; + self.file_name

    def update_attributes(self, data=None):
        &#34;&#34;&#34;
        Use the current self.cdata to update all the current atrributes
        :return:
        &#34;&#34;&#34;

        if not data:
            cdata = self.cdata
        else:
            cdata = self._data_cleaner(data)
            self.cdata = data
        self.errored_attributes = []
        self.try_store_attribute(&#34;post_id&#34;, &#34;cid&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
        self.try_store_attribute(&#34;text&#34;, &#34;text&#34;)
        try:
            self.creator_id = cdata[&#39;user&#39;][&#39;id&#39;]
            self.creator_name = cdata[&#39;user&#39;][&#39;original_nick&#39;]
        except KeyError:
            self.errored_attributes.append(&#34;creator_id&#34;)
            self.errored_attributes.append(&#34;creator_name&#34;)
        try:
            self.endpoints = {&#39;main&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}&#39;,
                              &#39;replies&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}/replies&#39;,
                              &#39;smiles&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}/smiles&#39;}
            self.replies = Queue(Reply, self.endpoints[&#39;replies&#39;])
            self.smiles = Queue(User, self.endpoints[&#39;smiles&#39;])
            self.smiles.auth_token = BEARER_TOKEN  # getting who smiled comment/reply requires bearer for what ever reason
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.append(&#34;replies&#34;)
            self.errored_attributes.append(&#34;smiles&#34;)

    def _data_cleaner(self, var):
        # this returns a cleaned dict after striping the output it deems unneeded
        # this one was made for posts and needs to be calibrated
        if type(var) == dict:
            if &#34;error&#34; in var and &#34;not_found&#34; == var[&#39;error&#39;]:
                raise NoContent()
            if &#34;id&#34; in var:
                return var
            elif &#34;data&#34; in var:
                return var[&#34;data&#34;][&#34;comment&#34;]
        elif type(var) == list:
            return var[0]
        pprint(var)
        print(&#34;cleaner failed to find key&#34;)
        raise KeyError
    
    def reload(self):
        self.__init__(self.post_id, self.id)

    def add_reply(self, thing):
        &#34;&#34;&#34;
        Simple way to add a direct reply
        :param thing: reply object
        :return: None
        &#34;&#34;&#34;
        self.replies.store(thing)
        return self

    def get_id_object(self, id_to_check: str):
        &#34;&#34;&#34;
        Will return the reply object with the id.
        :param id_to_check: the id of the object
        :return: Reply object if found, else None
        &#34;&#34;&#34;
        if id_to_check == self.id:
            return self
        else:
            for a in self.replies:
                check_in = a.get_id_object(id_to_check=id_to_check)
                if check_in is not None:
                    return check_in
            return None

    def nest_replies(self):
        &#34;&#34;&#34;
        Take the replies stared in self.replies and properly nest them.
        :return: self
        &#34;&#34;&#34;

        temp_stored_content = []
        for a in self.replies.stored_content:
            found = False
            for b in temp_stored_content:
                target = b.get_id_object(a.parent_comment_id)
                if target is None:
                    continue
                target.add_reply(a)
                found = True
            if not found:
                temp_stored_content.append(a)
        self.replies.stored_content = temp_stored_content
        return self

    def tree_cdata(self) -&gt; tuple:
        &#34;&#34;&#34;
        Like id_tree, but this one returns all the cdata instead of only ids
        :return: cdata in nested form
        &#34;&#34;&#34;

        reply_list = []
        for a in self.replies:
            # todo remove this limiter
            sanity = a.tree()
            if &#34;last_reply&#34; in sanity[0]:
                del sanity[0][&#34;last_reply&#34;]
            reply_list.append(sanity)
        return self.cdata, reply_list


class Reply(Comment):
    &#34;&#34;&#34;
    While very simmilar to the comment object, there are a few new pieces of data that a reply has that needs te be stored
    &#34;&#34;&#34;

    def __init__(self, post_id: str = None, comment_id: str = None, data: dict = None, file_name: str = None):
        &#34;&#34;&#34;
        Works in the same way as the Comment class, this is just a special case
        &#34;&#34;&#34;
        super().__init__(post_id, comment_id, data, file_name)  # this should also auto clean the data being passed and stored

        if not file_name:
            self.update_attributes()

    def update_attributes(self, data: dict = None):

        if data:
            self.cdata = self._data_cleaner(data)

        super().update_attributes()
        self.try_store_attribute(&#34;depth&#34;, &#34;depth&#34;)
        self.try_store_attribute(&#34;parent_comment_id&#34;, &#34;parent_comm_id&#34;)
        self.try_store_attribute(&#34;root_comment_id&#34;, &#34;root_comm_id&#34;)


class Post(IfBase):
    &#34;&#34;&#34;
    This holds a single post, and parses the data for more easy use.
    &#34;&#34;&#34;

    def __init__(self, post_id: str = None, data: dict = None, file_name: str = None):
        &#34;&#34;&#34;
        post_id is the direct way to call post json info
        :param post_id: post id string
        &#34;&#34;&#34;
        logger.info(&#34;Post object created&#34;)

        super().__init__(file_name)
        self.data_attributes.extend((&#39;comments&#39;, &#39;repubs&#39;, &#39;smiles&#39;))

        if file_name:
            self.load_file(file_name)
        else:
            if post_id:
                data = api_call(&#34;https://api.ifunny.mobi/v4/content/&#34; + post_id, auth=BASIC_TOKEN)
                # print(data)
                self.cdata = self._data_cleaner(data)
                # print(self.cdata)
            elif data:
                self.cdata = self._data_cleaner(data)
            elif not any((post_id, data, file_name)):
                raise ValueError(&#34;need args&#34;)

            self.update_attributes()

            if &#34;id&#34; not in self.errored_attributes:
                self.file_name = self.id + &#34;_&#34; + self.file_name


    def update_attributes(self, data: dict = None):

        if not data:
            cdata = self.cdata
        else:
            cdata = data
            self.cdata = cdata

        self.errored_attributes = []
        try:
            self.creator_id = cdata[&#34;creator&#34;][&#34;id&#34;]
            self.creator_name = cdata[&#34;creator&#34;][&#34;original_nick&#34;]  # uses original name for consistency over time hopefully
        except KeyError:
            self.errored_attributes.append(&#34;creator_id&#34;)
            self.errored_attributes.append(&#34;creator_name&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;link&#34;, &#34;link&#34;)
        self.try_store_attribute(&#34;url&#34;, &#34;url&#34;)
        self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
        self.try_store_attribute(&#34;type&#34;, &#34;type&#34;)
        # if self.endpoints fails, so will all the queues
        try:
            self.endpoints = {&#39;main&#39;: &#34;https://api.ifunny.mobi/v4/content/&#34; + self.id,
                              &#39;comments&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/comments&#39;,
                              &#39;repubs&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/republished&#39;,
                              &#39;smiles&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/smiles&#39;}
            self.comments = Queue(Comment, self.endpoints[&#39;comments&#39;])
            self.repubs = Queue(User, self.endpoints[&#39;repubs&#39;])
            self.smiles = Queue(User, self.endpoints[&#39;smiles&#39;])
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.append(&#34;comments&#34;)
            self.errored_attributes.append(&#34;repubs&#34;)
            self.errored_attributes.append(&#34;smiles&#34;)

    def _data_cleaner(self, var):
        # this returns a cleaned dict after striping the output it deems unneeded. Also only returns first object if given a list

        # print(var)
        if type(var) == dict:
            if &#34;error&#34; in var and &#34;not_found&#34; == var[&#39;error&#39;]:
                raise NoContent
            if &#34;id&#34; in var:
                return var
            elif &#34;data&#34; in var:
                if &#34;id&#34; in var[&#34;data&#34;]:
                    logger.info(var)
                    return var[&#34;data&#34;]
                return var[&#34;data&#34;][&#39;content&#39;][&#39;items&#39;][0]
        elif type(var) == list:
            return self._data_cleaner(var[0])

        print(var)
        print(&#34;cleaner failed to find key&#34;)
        raise KeyError
    
    def reload(self):
        self.__init__(self.id)

    def add_comment(self, thing):
        self.comments.store(thing)
        return self

    def load_comment_tree(self, comments: int = None, reply_limit: int = None):
        &#34;&#34;&#34;
        I don&#39;t want load functions, but this one is more complex so it gets to stay.
        :param comments: How many comments to try to load
        :param reply_limit: How many relpies to each comment loaded
        :return: None
        &#34;&#34;&#34;
        self.comments.load(limit=comments)
        for a in self.comments:
            a.replies.load(reply_limit)
            a.nest_replies()
        return self

    def comment_tree(self) -&gt; list:
        reply_list = []
        for a in self.comments:
            reply_list.append(a.tree())
        return reply_list

    def get_id_object(self, id_to_check: str):
        &#34;&#34;&#34;
        Searches for id within the nested comments.
        :param id_to_check: Doesn&#39;t care about the class will just get its id.
        :return:
        &#34;&#34;&#34;
        # pprint(self.cdata)
        if id_to_check == self.id:
            return self
        else:
            for a in self.comments:
                check_in = a.get_id_object(id_to_check=id_to_check)
                if check_in is not None:
                    return check_in
            return None


class User(IfBase):
    &#34;&#34;&#34;
    This holds the user data and gets called at various different times. Just because data exists, it doesn&#39;t mean all data get loaded. May need to reload() to have all info
    &#34;&#34;&#34;
    def __init__(self, creator_id: str = None, data: dict = None, file_name: str = None):
        logger.info(&#34;Creator object created&#34;)

        super().__init__(file_name)
        self.data_attributes.extend((&#39;posts&#39;, &#39;subscriptions&#39;, &#39;subscribers&#39;))

        if file_name:
            self.load_file(file_name)
        else:
            if creator_id:
                data = api_call(f&#34;https://api.ifunny.mobi/v4/users/&#34; + creator_id, auth=BASIC_TOKEN)
                cdata = self._data_cleaner(data)
                self.cdata = cdata
            if data:
                cdata = self._data_cleaner(data)
                self.cdata = cdata
            elif not any((creator_id, data, file_name)):
                raise ValueError(&#34;need args&#34;)

            self.update_attributes()

            if not file_name and &#34;id&#34; not in self.errored_attributes:
                self.file_name = self.id + &#34;_&#34; + self.file_name

    def update_attributes(self, data: dict = None):

        if not data:
            cdata = self.cdata
        else:
            cdata = self._data_cleaner(data)
            self.cdata = cdata

        self.errored_attributes = []

        try:
            self.days = cdata[&#34;meme_experience&#34;][&#34;days&#34;]
        except KeyError:
            self.errored_attributes.append(&#34;days&#34;)

        self.try_store_attribute(&#34;web_url&#34;, &#34;web_url&#34;)
        self.try_store_attribute(&#34;about&#34;, &#34;about&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;name&#34;, &#34;nick&#34;)
        self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
        self.try_store_attribute(&#34;total_posts&#34;, &#34;total_posts&#34;)
        try:
            self.endpoints = {&#34;main&#34;: f&#34;https://api.ifunny.mobi/v4/account&#34;,
                              &#39;posts&#39;: f&#39;https://api.ifunny.mobi/v4/timelines/users/&#39; + self.id,
                              &#39;subscriptions&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscriptions&#34;,
                              &#39;subscribers&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscribers&#34;}
            self.posts = Queue(Post, self.endpoints[&#39;posts&#39;])
            self.subscriptions = Queue(User, self.endpoints[&#39;subscriptions&#39;])
            self.subscribers = Queue(User, self.endpoints[&#39;subscribers&#39;])
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.append(&#34;posts&#34;)
            self.errored_attributes.append(&#34;subscriptions&#34;)
            self.errored_attributes.append(&#34;subscribers&#34;)

    def _data_cleaner(self, var):
        &#34;&#34;&#34;
        Cleans given data to make it uniform for the
        :param var:
        :return:
        &#34;&#34;&#34;
        # this returns a cleaned dict after striping the output it deems unneeded. Also only returns first object if given a list

        if type(var) == dict:
            if &#34;error&#34; in var and &#34;not_found&#34; == var[&#39;error&#39;]:
                raise NoContent()
            if &#34;id&#34; in var:
                return var
            elif &#34;data&#34; in var:
                if &#34;id&#34; in var[&#34;data&#34;]:
                    return var[&#34;data&#34;]
                return var[&#34;data&#34;][&#39;content&#39;][&#39;items&#39;][0]
        elif type(var) == list:
            return var[0]

        print(var)
        print(self.cdata)
        print(&#34;cleaner failed to find key&#34;)
        raise KeyError
    
    def reload(self):
        self.__init__(self.id)

    def add_post(self, thing):
        self.posts.store(thing)


# uses bearer to login and get info
class Account(IfBase):
    &#34;&#34;&#34;
    By using the bearer token, get user info. This is just a more advanced User class.
    &#34;&#34;&#34;

    def __init__(self, data: dict = None, file_name: str = None):

        super().__init__(file_name)
        self.data_attributes.extend((&#39;posts&#39;, &#39;subscriptions&#39;, &#39;subscribers&#39;, &#39;comments&#39;, &#39;guests&#39;, &#39;blocked&#39;, &#39;smiles&#39;, &#39;sub_feed&#39;))

        if file_name:
            self.load_file(file_name)
        else:
            if data:
                self.cdata = data
            else:
                self.cdata = api_call(url=f&#34;https://api.ifunny.mobi/v4/account&#34;, auth=BEARER_TOKEN, params={&#34;limit&#34;: 1})[&#39;data&#39;]

            self.update_attributes()

            if not file_name and &#34;id&#34; not in self.errored_attributes:
                self.file_name = self.id + &#34;_&#34; + self.file_name

    def update_attributes(self, data: dict = None):

        if not data:
            cdata = self.cdata
        else:
            cdata = data
            self.cdata = cdata
        self.try_store_attribute(&#34;about&#34;, &#34;about&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;name&#34;, &#34;nick&#34;)
        self.try_store_attribute(&#39;stats&#39;, &#34;num&#34;)
        self.try_store_attribute(&#34;web_url&#34;, &#34;web_url&#34;)
        try:
            self.days = cdata[&#39;meme_experience&#39;][&#39;days&#39;]
        except KeyError:
            self.errored_attributes.append(&#34;days&#34;)
        try:
            self.endpoints = {&#34;main&#34;: f&#34;https://api.ifunny.mobi/v4/account&#34;,
                              &#39;posts&#39;: f&#39;https://api.ifunny.mobi/v4/timelines/users/&#39; + self.id,
                              &#39;subscriptions&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscriptions&#34;,
                              &#39;subscribers&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscribers&#34;,
                              &#39;comments&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/comments&#34;,  # Comment objects
                              &#39;guests&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/guests&#34;,  # User objects
                              &#39;blocked&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/blocked&#34;,  # User objects
                              &#39;smiles&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/content_smiles&#34;,  # Post objects
                              &#39;sub_feed&#39;: f&#34;https://api.ifunny.mobi/v4/timelines/home&#34;}  # current sub feed
            self.posts = Queue(Post, self.endpoints[&#39;posts&#39;])
            self.subscriptions = Queue(User, self.endpoints[&#39;subscriptions&#39;])
            self.subscribers = Queue(User, self.endpoints[&#39;subscribers&#39;])
            self.comments = Queue(Comment, self.endpoints[&#39;comments&#39;])
            self.guests = Queue(User, self.endpoints[&#39;guests&#39;])  # will load 1 less than specified fixme
            self.blocked = Queue(User, self.endpoints[&#39;blocked&#39;])
            self.smiles = Queue(Post, self.endpoints[&#39;smiles&#39;])
            self.sub_feed = Queue(Post, self.endpoints[&#39;sub_feed&#39;])
            # these need the bearer auth to work
            self.comments.auth_token = BEARER_TOKEN
            self.guests.auth_token = BEARER_TOKEN
            self.blocked.auth_token = BEARER_TOKEN
            self.smiles.auth_token = BEARER_TOKEN
            self.sub_feed.auth_token = BEARER_TOKEN
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.extend((&#34;posts&#34;, &#34;subscriptions&#34;, &#34;subscribers&#34;, &#39;comments&#39;, &#39;guests&#39;, &#39;blocked&#39;,
                                            &#39;smiles&#39;, &#39;sub_feed&#39;))
        
    def reload(self):
        self.__init__()


def get_basic(identifier: str = None) -&gt; str:
    &#34;&#34;&#34;
    This is used to get a working Basic token. This should be used to set the global BASIC_TOKEN var if one is needed.
    :param identifier: If not set, identifier will be a random 32 len string? It should work no matter what it is.
    :return: A prepared Basic token which can now directly be used in headers.
    &#34;&#34;&#34;
    if identifier is None:
        hex_string = os.urandom(32).hex().upper()
    else:
        hex_string = identifier
    client_id = &#34;&#34;&#34;MsOIJ39Q28&#34;&#34;&#34;
    client_secret = &#34;&#34;&#34;PTDc3H8a)Vi=UYap&#34;&#34;&#34;
    hex_id = hex_string + &#39;_&#39; + client_id
    hash_decoded = hex_string + &#39;:&#39; + client_id + &#39;:&#39; + client_secret
    hash_encoded = hashlib.sha1(hash_decoded.encode(&#39;utf-8&#39;)).hexdigest()
    return &#34;Basic &#34; + base64.b64encode(bytes(hex_id + &#39;:&#39; + hash_encoded, &#39;utf-8&#39;)).decode()


def get_bearer(basic_token: str, email: str, password: str) -&gt; str:
    &#34;&#34;&#34;
    Basically logs in to generate a Bearer token. As this is equivalent to a login, it is recommended to save token to
    avoid calling this many times. It is recommended to call load_auths() instead.
    :param basic_token: an identification Basic token, use get_basic() to get one
    :type basic_token: str
    :param email: Ifunny account email
    :type email: str
    :param password: Ifunny account password
    :type password: str
    :return: This will return a prepared Bearer token that is ready to use in headers
    :rtype: str
    &#34;&#34;&#34;
    headers = {&#34;Authorization&#34;: basic_token}
    data = {&#34;username&#34;: email, &#34;password&#34;: password, &#34;grant_type&#34;: &#34;password&#34;}
    # print(headers, data)
    response = requests.post(&#34;https://api.ifunny.mobi/v4/oauth2/token&#34;, headers=headers, data=data)
    thing = response.json()
    try:
        return &#34;Bearer &#34; + thing[&#34;access_token&#34;]
    except KeyError:
        print(&#34;Something went wrong (Expected if generating new login)&#34;)
        print(response.content)
        raise KeyError


def load_auths(identifier: str = None, email: str = None, password: str = None, force: bool = False, file: str = &#39;auth_data&#39;) -&gt; None:
    &#34;&#34;&#34;
    This will set Basic and Bearer global vars by generating them and then saving them to file, or reading from file.
    If read from file, no prams are needed
    :param identifier: Used by servers to identify device, useful if consistency is needed. Always optional.
    :type identifier: str
    :param email: Ifunny account login email
    :type email: str
    :param password: Ifunny account login password
    :type password: str
    :param force: forcibly get new auths and overwrite saved ones (use if bearer got killed)
    :type force: bool
    :return: No return, but global vars are now set. Will error if something goes wrong.
    :rtype: None
    &#34;&#34;&#34;
    logger.info(&#34;running login function&#34;)
    global BASIC_TOKEN, BEARER_TOKEN
    if os.path.isfile(file) and not force:
        # todo change this to json?
        # load tokens from file
        with open(file, &#34;r&#34;) as f:
            thing = eval(f.read())
        BASIC_TOKEN = thing[&#34;Basic&#34;]
        BEARER_TOKEN = thing[&#34;Bearer&#34;]
        return
    # file not found
    if None in (email, password):
        # no file and missing needed params
        print(&#34;need email and/or password&#34;)
        os.system(&#34;pause&#34;)
        exit()
    BASIC_TOKEN = get_basic(identifier=identifier)
    try:
        BEARER_TOKEN = get_bearer(BASIC_TOKEN, email=email, password=password)
    except KeyError:
        logger.warning(&#34;New bearer, 10s login delay&#34;)
        time.sleep(10)
        BEARER_TOKEN = get_bearer(BASIC_TOKEN, email=email, password=password)
    with open(file, &#34;w&#34;) as f:
        f.write(str({&#34;Basic&#34;: BASIC_TOKEN, &#34;Bearer&#34;: BEARER_TOKEN}))
    return


def kill_bearer(bearer: str = BEARER_TOKEN):
    &#34;&#34;&#34;
    Untested but should kill the bearer token
    :param bearer:
    :return:
    &#34;&#34;&#34;
    if &#34;Bearer &#34; in bearer:
        bearer = bearer[7:]
    headers = {&#34;Authorization&#34;: BASIC_TOKEN}
    response = requests.post(url=&#39;https://api.ifunny.mobi/v4/oauth2/revoke&#39;, headers=headers, data={&#39;token&#39;: bearer})
    return response


def api_call(url: str, auth: str = None, params: dict = None, method=&#34;GET&#34;) -&gt; dict:
    &#34;&#34;&#34;
    To simplify the api calls and hopefully clean up code
    :param url: The link that gets sent to, id will have to be embeded
    :type url: str
    :param auth: The needed auth token as a string
    :type auth: str
    :param params: extra things like limit
    :type params: dict
    :param method:
    :return: The parsed response
    :rtype: dict
    &#34;&#34;&#34;
    logger.debug(&#34;making api call&#34;)
    if auth is None:
        raise MissingAuthToken()
    header_thing = {&#39;Authorization&#39;: auth}
    # print(params)
    try:
        response = requests.request(method, url, headers=header_thing, params=params)
        parsed = json.loads(response.content)
        if &#39;error&#39; in parsed:
            raise KeyError
    except:
        logger.warning(&#39;error/exception in api_call&#39;)
        try:
            response = requests.request(method, url, headers=header_thing, params=params)
            parsed = json.loads(response.content)
            if &#39;error&#39; in parsed:
                raise KeyError
        except:
            time.sleep(5)
            logger.warning(&#39;error/exception in api_call (2nd/delayed call)&#39;)
            try:
                response = requests.request(method, url, headers=header_thing, params=params)
                parsed = json.loads(response.content)
                if &#39;error&#39; in parsed:
                    raise KeyError
            except:
                print(&#39;Something errored&#39;)
                print(url)
                if response:
                    print(response.content)
                raise NoContent
    return parsed


def dl_from_link(url: str, file_name: str = None):
    &#34;&#34;&#34;
    Does as name implies.
    :param url: file source
    :param file_name: where to put it, and what to name it untested if other paths work, I just use same dir.
    :return: None
    &#34;&#34;&#34;
    if not file_name:
        name = url.split(&#39;/&#39;)[-1]
    else:
        name = file_name
    print(f&#39;dl: {name}&#39;)
    with open(name, &#39;wb&#39;) as f:
        f.write(requests.get(url).content)


def post_from_url(url: str) -&gt; Post:
    &#34;&#34;&#34;
    Uses the real post url and finds the id within the page.
    :param url: Link to ifunny site
    :type url: str
    :return: The post itself as the Post object. Post.id will return the id
    :rtype: Post
    &#34;&#34;&#34;
    request = requests.get(url)
    tree = html.fromstring(request.content)
    # this might break
    post_id = tree.xpath(&#34;//li[@class=&#39;stream__item &#39;]/div[@class=&#39;post&#39;]/@data-id&#34;)[0]  # this can break
    # print(post_id)
    return Post(post_id=post_id)


def post_from_id(post_id: str) -&gt; Post:
    &#34;&#34;&#34;
    Not needed as Post() exists, but here to parallel with post_from_url()
    :param post_id: id of the post
    :type post_id: str
    :return: Post object
    :rtype: Post
    &#34;&#34;&#34;
    return Post(post_id=post_id)


def recursive_id_print(base_comment, target: tuple, indent_scale: int = 3, current_indent: int = 0) -&gt; None:
    &#34;&#34;&#34;
    A function used to try to cleanly print all replies in the correct nested way
    :param base_comment: The anchor comment for this branch
    :param target: What gets attached
    :param indent_scale: How big is the indent
    :param current_indent: How much is it indented
    :return: None, it just prints
    &#34;&#34;&#34;
    if isinstance(base_comment, Post):
        # pprint(base_comment.cdata)
        print(&#34; &#34; * current_indent + base_comment.id)
        for a in target:
            recursive_id_print(base_comment.get_id_object(a[0]), a, current_indent=current_indent + indent_scale)
    else:
        print(&#34; &#34; * (current_indent - 0) + base_comment.get_id_object(target[0]).text)
        for a in target[1]:
            recursive_id_print(base_comment, a, current_indent=current_indent + indent_scale)


def get_author_id(text: str, search_limit: int = 1):
    # from a post url
    if text.__contains__(&#34;ifunny.&#34;):
        &#34;&#34;&#34;
        When using a url to profile, find author_id in page
        &#34;&#34;&#34;
        request = requests.get(text)
        # print(text)
        # print(request.text)
        tree = html.fromstring(request.content)
        # this might break
        # print(tree.xpath(&#39;//script&#39;)[0].text)
        potential_id = tree.xpath(&#39;//script&#39;)
        for a in potential_id:
            if &#34;__INITIAL_STATE__&#34; in a.text:
                found = a.text
                # print(found)
                json_object = json.loads(found.split(&#39; = &#39;)[1][:-1])
                author_id = json_object[&#34;user&#34;][&#34;data&#34;][&#34;id&#34;]
                # print(author_id)
                return author_id
    else:
        &#34;&#34;&#34;
        When searching by name and using ifunny&#39;s searching (can&#39;t find shadowbanned/nonexistent names)
        &#34;&#34;&#34;
        requst = api_call(url=f&#39;https://api.ifunny.mobi/v4/search/users_for_mentions&#39;, auth=BEARER_TOKEN, params={&#34;q&#34;: text, &#39;limit&#39;: search_limit})
        preped = requst[&#39;data&#39;][&#39;users&#39;][&#39;items&#39;]
        if search_limit == 1:
            try:
                return preped[0][&#34;id&#34;]
            except IndexError:
                print(preped)
        return [(a[&#34;id&#34;], a[&#39;original_nick&#39;]) for a in preped]


def get_features(limit: int = 0) -&gt; Queue:
    &#34;&#34;&#34;
    Get the current features
    :param limit: How many to grab
    :return: Queue object with the current features
    &#34;&#34;&#34;
    feats = Queue(Post, &#34;https://api.ifunny.mobi/v4/feeds/featured&#34;)
    feats.load(limit=limit)
    return feats


def get_popular(limit: int = 0) -&gt; Queue:
    &#34;&#34;&#34;
    Get random featured posts
    :param limit: How many to load
    :return: The Queue object
    &#34;&#34;&#34;
    pop = Queue(Post, &#34;https://api.ifunny.mobi/v4/feeds/popular&#34;)
    pop.load(limit=limit)
    return pop


def get_collective(limit: int = 0) -&gt; Queue:
    &#34;&#34;&#34;
    This one almost destroys anything I had organized because it needs post instead of get.
    If limit == None then it will return a clean Queue object for use.
    :param limit: How many to load
    :return: The current collective
    &#34;&#34;&#34;
    collective = Queue(Post, &#34;https://api.ifunny.mobi/v4/feeds/collective&#34;)
    if limit is None:
        collective.load(limit=0)
    else:
        collective.load(limit=limit)
    return collective

&#34;&#34;&#34;
Made by Nam. Discord: that_dude#1313, Github: XDEmer0r-L0rd-360-G0d-SlayerXD
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ifunny_lib.api_call"><code class="name flex">
<span>def <span class="ident">api_call</span></span>(<span>url:str, auth:str=None, params:dict=None, method='GET') >dict</span>
</code></dt>
<dd>
<div class="desc"><p>To simplify the api calls and hopefully clean up code
:param url: The link that gets sent to, id will have to be embeded
:type url: str
:param auth: The needed auth token as a string
:type auth: str
:param params: extra things like limit
:type params: dict
:param method:
:return: The parsed response
:rtype: dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api_call(url: str, auth: str = None, params: dict = None, method=&#34;GET&#34;) -&gt; dict:
    &#34;&#34;&#34;
    To simplify the api calls and hopefully clean up code
    :param url: The link that gets sent to, id will have to be embeded
    :type url: str
    :param auth: The needed auth token as a string
    :type auth: str
    :param params: extra things like limit
    :type params: dict
    :param method:
    :return: The parsed response
    :rtype: dict
    &#34;&#34;&#34;
    logger.debug(&#34;making api call&#34;)
    if auth is None:
        raise MissingAuthToken()
    header_thing = {&#39;Authorization&#39;: auth}
    # print(params)
    try:
        response = requests.request(method, url, headers=header_thing, params=params)
        parsed = json.loads(response.content)
        if &#39;error&#39; in parsed:
            raise KeyError
    except:
        logger.warning(&#39;error/exception in api_call&#39;)
        try:
            response = requests.request(method, url, headers=header_thing, params=params)
            parsed = json.loads(response.content)
            if &#39;error&#39; in parsed:
                raise KeyError
        except:
            time.sleep(5)
            logger.warning(&#39;error/exception in api_call (2nd/delayed call)&#39;)
            try:
                response = requests.request(method, url, headers=header_thing, params=params)
                parsed = json.loads(response.content)
                if &#39;error&#39; in parsed:
                    raise KeyError
            except:
                print(&#39;Something errored&#39;)
                print(url)
                if response:
                    print(response.content)
                raise NoContent
    return parsed</code></pre>
</details>
</dd>
<dt id="ifunny_lib.dl_from_link"><code class="name flex">
<span>def <span class="ident">dl_from_link</span></span>(<span>url:str, file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Does as name implies.
:param url: file source
:param file_name: where to put it, and what to name it untested if other paths work, I just use same dir.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dl_from_link(url: str, file_name: str = None):
    &#34;&#34;&#34;
    Does as name implies.
    :param url: file source
    :param file_name: where to put it, and what to name it untested if other paths work, I just use same dir.
    :return: None
    &#34;&#34;&#34;
    if not file_name:
        name = url.split(&#39;/&#39;)[-1]
    else:
        name = file_name
    print(f&#39;dl: {name}&#39;)
    with open(name, &#39;wb&#39;) as f:
        f.write(requests.get(url).content)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.get_author_id"><code class="name flex">
<span>def <span class="ident">get_author_id</span></span>(<span>text:str, search_limit:int=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_author_id(text: str, search_limit: int = 1):
    # from a post url
    if text.__contains__(&#34;ifunny.&#34;):
        &#34;&#34;&#34;
        When using a url to profile, find author_id in page
        &#34;&#34;&#34;
        request = requests.get(text)
        # print(text)
        # print(request.text)
        tree = html.fromstring(request.content)
        # this might break
        # print(tree.xpath(&#39;//script&#39;)[0].text)
        potential_id = tree.xpath(&#39;//script&#39;)
        for a in potential_id:
            if &#34;__INITIAL_STATE__&#34; in a.text:
                found = a.text
                # print(found)
                json_object = json.loads(found.split(&#39; = &#39;)[1][:-1])
                author_id = json_object[&#34;user&#34;][&#34;data&#34;][&#34;id&#34;]
                # print(author_id)
                return author_id
    else:
        &#34;&#34;&#34;
        When searching by name and using ifunny&#39;s searching (can&#39;t find shadowbanned/nonexistent names)
        &#34;&#34;&#34;
        requst = api_call(url=f&#39;https://api.ifunny.mobi/v4/search/users_for_mentions&#39;, auth=BEARER_TOKEN, params={&#34;q&#34;: text, &#39;limit&#39;: search_limit})
        preped = requst[&#39;data&#39;][&#39;users&#39;][&#39;items&#39;]
        if search_limit == 1:
            try:
                return preped[0][&#34;id&#34;]
            except IndexError:
                print(preped)
        return [(a[&#34;id&#34;], a[&#39;original_nick&#39;]) for a in preped]</code></pre>
</details>
</dd>
<dt id="ifunny_lib.get_basic"><code class="name flex">
<span>def <span class="ident">get_basic</span></span>(<span>identifier:str=None) >str</span>
</code></dt>
<dd>
<div class="desc"><p>This is used to get a working Basic token. This should be used to set the global BASIC_TOKEN var if one is needed.
:param identifier: If not set, identifier will be a random 32 len string? It should work no matter what it is.
:return: A prepared Basic token which can now directly be used in headers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_basic(identifier: str = None) -&gt; str:
    &#34;&#34;&#34;
    This is used to get a working Basic token. This should be used to set the global BASIC_TOKEN var if one is needed.
    :param identifier: If not set, identifier will be a random 32 len string? It should work no matter what it is.
    :return: A prepared Basic token which can now directly be used in headers.
    &#34;&#34;&#34;
    if identifier is None:
        hex_string = os.urandom(32).hex().upper()
    else:
        hex_string = identifier
    client_id = &#34;&#34;&#34;MsOIJ39Q28&#34;&#34;&#34;
    client_secret = &#34;&#34;&#34;PTDc3H8a)Vi=UYap&#34;&#34;&#34;
    hex_id = hex_string + &#39;_&#39; + client_id
    hash_decoded = hex_string + &#39;:&#39; + client_id + &#39;:&#39; + client_secret
    hash_encoded = hashlib.sha1(hash_decoded.encode(&#39;utf-8&#39;)).hexdigest()
    return &#34;Basic &#34; + base64.b64encode(bytes(hex_id + &#39;:&#39; + hash_encoded, &#39;utf-8&#39;)).decode()</code></pre>
</details>
</dd>
<dt id="ifunny_lib.get_bearer"><code class="name flex">
<span>def <span class="ident">get_bearer</span></span>(<span>basic_token:str, email:str, password:str) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Basically logs in to generate a Bearer token. As this is equivalent to a login, it is recommended to save token to
avoid calling this many times. It is recommended to call load_auths() instead.
:param basic_token: an identification Basic token, use get_basic() to get one
:type basic_token: str
:param email: Ifunny account email
:type email: str
:param password: Ifunny account password
:type password: str
:return: This will return a prepared Bearer token that is ready to use in headers
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bearer(basic_token: str, email: str, password: str) -&gt; str:
    &#34;&#34;&#34;
    Basically logs in to generate a Bearer token. As this is equivalent to a login, it is recommended to save token to
    avoid calling this many times. It is recommended to call load_auths() instead.
    :param basic_token: an identification Basic token, use get_basic() to get one
    :type basic_token: str
    :param email: Ifunny account email
    :type email: str
    :param password: Ifunny account password
    :type password: str
    :return: This will return a prepared Bearer token that is ready to use in headers
    :rtype: str
    &#34;&#34;&#34;
    headers = {&#34;Authorization&#34;: basic_token}
    data = {&#34;username&#34;: email, &#34;password&#34;: password, &#34;grant_type&#34;: &#34;password&#34;}
    # print(headers, data)
    response = requests.post(&#34;https://api.ifunny.mobi/v4/oauth2/token&#34;, headers=headers, data=data)
    thing = response.json()
    try:
        return &#34;Bearer &#34; + thing[&#34;access_token&#34;]
    except KeyError:
        print(&#34;Something went wrong (Expected if generating new login)&#34;)
        print(response.content)
        raise KeyError</code></pre>
</details>
</dd>
<dt id="ifunny_lib.get_collective"><code class="name flex">
<span>def <span class="ident">get_collective</span></span>(<span>limit:int=0) ><a title="ifunny_lib.Queue" href="#ifunny_lib.Queue">Queue</a></span>
</code></dt>
<dd>
<div class="desc"><p>This one almost destroys anything I had organized because it needs post instead of get.
If limit == None then it will return a clean Queue object for use.
:param limit: How many to load
:return: The current collective</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_collective(limit: int = 0) -&gt; Queue:
    &#34;&#34;&#34;
    This one almost destroys anything I had organized because it needs post instead of get.
    If limit == None then it will return a clean Queue object for use.
    :param limit: How many to load
    :return: The current collective
    &#34;&#34;&#34;
    collective = Queue(Post, &#34;https://api.ifunny.mobi/v4/feeds/collective&#34;)
    if limit is None:
        collective.load(limit=0)
    else:
        collective.load(limit=limit)
    return collective</code></pre>
</details>
</dd>
<dt id="ifunny_lib.get_features"><code class="name flex">
<span>def <span class="ident">get_features</span></span>(<span>limit:int=0) ><a title="ifunny_lib.Queue" href="#ifunny_lib.Queue">Queue</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the current features
:param limit: How many to grab
:return: Queue object with the current features</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_features(limit: int = 0) -&gt; Queue:
    &#34;&#34;&#34;
    Get the current features
    :param limit: How many to grab
    :return: Queue object with the current features
    &#34;&#34;&#34;
    feats = Queue(Post, &#34;https://api.ifunny.mobi/v4/feeds/featured&#34;)
    feats.load(limit=limit)
    return feats</code></pre>
</details>
</dd>
<dt id="ifunny_lib.get_popular"><code class="name flex">
<span>def <span class="ident">get_popular</span></span>(<span>limit:int=0) ><a title="ifunny_lib.Queue" href="#ifunny_lib.Queue">Queue</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get random featured posts
:param limit: How many to load
:return: The Queue object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_popular(limit: int = 0) -&gt; Queue:
    &#34;&#34;&#34;
    Get random featured posts
    :param limit: How many to load
    :return: The Queue object
    &#34;&#34;&#34;
    pop = Queue(Post, &#34;https://api.ifunny.mobi/v4/feeds/popular&#34;)
    pop.load(limit=limit)
    return pop</code></pre>
</details>
</dd>
<dt id="ifunny_lib.kill_bearer"><code class="name flex">
<span>def <span class="ident">kill_bearer</span></span>(<span>bearer:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>Untested but should kill the bearer token
:param bearer:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_bearer(bearer: str = BEARER_TOKEN):
    &#34;&#34;&#34;
    Untested but should kill the bearer token
    :param bearer:
    :return:
    &#34;&#34;&#34;
    if &#34;Bearer &#34; in bearer:
        bearer = bearer[7:]
    headers = {&#34;Authorization&#34;: BASIC_TOKEN}
    response = requests.post(url=&#39;https://api.ifunny.mobi/v4/oauth2/revoke&#39;, headers=headers, data={&#39;token&#39;: bearer})
    return response</code></pre>
</details>
</dd>
<dt id="ifunny_lib.load_auths"><code class="name flex">
<span>def <span class="ident">load_auths</span></span>(<span>identifier:str=None, email:str=None, password:str=None, force:bool=False, file:str='auth_data') >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This will set Basic and Bearer global vars by generating them and then saving them to file, or reading from file.
If read from file, no prams are needed
:param identifier: Used by servers to identify device, useful if consistency is needed. Always optional.
:type identifier: str
:param email: Ifunny account login email
:type email: str
:param password: Ifunny account login password
:type password: str
:param force: forcibly get new auths and overwrite saved ones (use if bearer got killed)
:type force: bool
:return: No return, but global vars are now set. Will error if something goes wrong.
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_auths(identifier: str = None, email: str = None, password: str = None, force: bool = False, file: str = &#39;auth_data&#39;) -&gt; None:
    &#34;&#34;&#34;
    This will set Basic and Bearer global vars by generating them and then saving them to file, or reading from file.
    If read from file, no prams are needed
    :param identifier: Used by servers to identify device, useful if consistency is needed. Always optional.
    :type identifier: str
    :param email: Ifunny account login email
    :type email: str
    :param password: Ifunny account login password
    :type password: str
    :param force: forcibly get new auths and overwrite saved ones (use if bearer got killed)
    :type force: bool
    :return: No return, but global vars are now set. Will error if something goes wrong.
    :rtype: None
    &#34;&#34;&#34;
    logger.info(&#34;running login function&#34;)
    global BASIC_TOKEN, BEARER_TOKEN
    if os.path.isfile(file) and not force:
        # todo change this to json?
        # load tokens from file
        with open(file, &#34;r&#34;) as f:
            thing = eval(f.read())
        BASIC_TOKEN = thing[&#34;Basic&#34;]
        BEARER_TOKEN = thing[&#34;Bearer&#34;]
        return
    # file not found
    if None in (email, password):
        # no file and missing needed params
        print(&#34;need email and/or password&#34;)
        os.system(&#34;pause&#34;)
        exit()
    BASIC_TOKEN = get_basic(identifier=identifier)
    try:
        BEARER_TOKEN = get_bearer(BASIC_TOKEN, email=email, password=password)
    except KeyError:
        logger.warning(&#34;New bearer, 10s login delay&#34;)
        time.sleep(10)
        BEARER_TOKEN = get_bearer(BASIC_TOKEN, email=email, password=password)
    with open(file, &#34;w&#34;) as f:
        f.write(str({&#34;Basic&#34;: BASIC_TOKEN, &#34;Bearer&#34;: BEARER_TOKEN}))
    return</code></pre>
</details>
</dd>
<dt id="ifunny_lib.post_from_id"><code class="name flex">
<span>def <span class="ident">post_from_id</span></span>(<span>post_id:str) ><a title="ifunny_lib.Post" href="#ifunny_lib.Post">Post</a></span>
</code></dt>
<dd>
<div class="desc"><p>Not needed as Post() exists, but here to parallel with post_from_url()
:param post_id: id of the post
:type post_id: str
:return: Post object
:rtype: Post</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_from_id(post_id: str) -&gt; Post:
    &#34;&#34;&#34;
    Not needed as Post() exists, but here to parallel with post_from_url()
    :param post_id: id of the post
    :type post_id: str
    :return: Post object
    :rtype: Post
    &#34;&#34;&#34;
    return Post(post_id=post_id)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.post_from_url"><code class="name flex">
<span>def <span class="ident">post_from_url</span></span>(<span>url:str) ><a title="ifunny_lib.Post" href="#ifunny_lib.Post">Post</a></span>
</code></dt>
<dd>
<div class="desc"><p>Uses the real post url and finds the id within the page.
:param url: Link to ifunny site
:type url: str
:return: The post itself as the Post object. Post.id will return the id
:rtype: Post</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_from_url(url: str) -&gt; Post:
    &#34;&#34;&#34;
    Uses the real post url and finds the id within the page.
    :param url: Link to ifunny site
    :type url: str
    :return: The post itself as the Post object. Post.id will return the id
    :rtype: Post
    &#34;&#34;&#34;
    request = requests.get(url)
    tree = html.fromstring(request.content)
    # this might break
    post_id = tree.xpath(&#34;//li[@class=&#39;stream__item &#39;]/div[@class=&#39;post&#39;]/@data-id&#34;)[0]  # this can break
    # print(post_id)
    return Post(post_id=post_id)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.recursive_id_print"><code class="name flex">
<span>def <span class="ident">recursive_id_print</span></span>(<span>base_comment, target:tuple, indent_scale:int=3, current_indent:int=0) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>A function used to try to cleanly print all replies in the correct nested way
:param base_comment: The anchor comment for this branch
:param target: What gets attached
:param indent_scale: How big is the indent
:param current_indent: How much is it indented
:return: None, it just prints</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursive_id_print(base_comment, target: tuple, indent_scale: int = 3, current_indent: int = 0) -&gt; None:
    &#34;&#34;&#34;
    A function used to try to cleanly print all replies in the correct nested way
    :param base_comment: The anchor comment for this branch
    :param target: What gets attached
    :param indent_scale: How big is the indent
    :param current_indent: How much is it indented
    :return: None, it just prints
    &#34;&#34;&#34;
    if isinstance(base_comment, Post):
        # pprint(base_comment.cdata)
        print(&#34; &#34; * current_indent + base_comment.id)
        for a in target:
            recursive_id_print(base_comment.get_id_object(a[0]), a, current_indent=current_indent + indent_scale)
    else:
        print(&#34; &#34; * (current_indent - 0) + base_comment.get_id_object(target[0]).text)
        for a in target[1]:
            recursive_id_print(base_comment, a, current_indent=current_indent + indent_scale)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ifunny_lib.Account"><code class="flex name class">
<span>class <span class="ident">Account</span></span>
<span>(</span><span>data:dict=None, file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>By using the bearer token, get user info. This is just a more advanced User class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Account(IfBase):
    &#34;&#34;&#34;
    By using the bearer token, get user info. This is just a more advanced User class.
    &#34;&#34;&#34;

    def __init__(self, data: dict = None, file_name: str = None):

        super().__init__(file_name)
        self.data_attributes.extend((&#39;posts&#39;, &#39;subscriptions&#39;, &#39;subscribers&#39;, &#39;comments&#39;, &#39;guests&#39;, &#39;blocked&#39;, &#39;smiles&#39;, &#39;sub_feed&#39;))

        if file_name:
            self.load_file(file_name)
        else:
            if data:
                self.cdata = data
            else:
                self.cdata = api_call(url=f&#34;https://api.ifunny.mobi/v4/account&#34;, auth=BEARER_TOKEN, params={&#34;limit&#34;: 1})[&#39;data&#39;]

            self.update_attributes()

            if not file_name and &#34;id&#34; not in self.errored_attributes:
                self.file_name = self.id + &#34;_&#34; + self.file_name

    def update_attributes(self, data: dict = None):

        if not data:
            cdata = self.cdata
        else:
            cdata = data
            self.cdata = cdata
        self.try_store_attribute(&#34;about&#34;, &#34;about&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;name&#34;, &#34;nick&#34;)
        self.try_store_attribute(&#39;stats&#39;, &#34;num&#34;)
        self.try_store_attribute(&#34;web_url&#34;, &#34;web_url&#34;)
        try:
            self.days = cdata[&#39;meme_experience&#39;][&#39;days&#39;]
        except KeyError:
            self.errored_attributes.append(&#34;days&#34;)
        try:
            self.endpoints = {&#34;main&#34;: f&#34;https://api.ifunny.mobi/v4/account&#34;,
                              &#39;posts&#39;: f&#39;https://api.ifunny.mobi/v4/timelines/users/&#39; + self.id,
                              &#39;subscriptions&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscriptions&#34;,
                              &#39;subscribers&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscribers&#34;,
                              &#39;comments&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/comments&#34;,  # Comment objects
                              &#39;guests&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/guests&#34;,  # User objects
                              &#39;blocked&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/blocked&#34;,  # User objects
                              &#39;smiles&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/content_smiles&#34;,  # Post objects
                              &#39;sub_feed&#39;: f&#34;https://api.ifunny.mobi/v4/timelines/home&#34;}  # current sub feed
            self.posts = Queue(Post, self.endpoints[&#39;posts&#39;])
            self.subscriptions = Queue(User, self.endpoints[&#39;subscriptions&#39;])
            self.subscribers = Queue(User, self.endpoints[&#39;subscribers&#39;])
            self.comments = Queue(Comment, self.endpoints[&#39;comments&#39;])
            self.guests = Queue(User, self.endpoints[&#39;guests&#39;])  # will load 1 less than specified fixme
            self.blocked = Queue(User, self.endpoints[&#39;blocked&#39;])
            self.smiles = Queue(Post, self.endpoints[&#39;smiles&#39;])
            self.sub_feed = Queue(Post, self.endpoints[&#39;sub_feed&#39;])
            # these need the bearer auth to work
            self.comments.auth_token = BEARER_TOKEN
            self.guests.auth_token = BEARER_TOKEN
            self.blocked.auth_token = BEARER_TOKEN
            self.smiles.auth_token = BEARER_TOKEN
            self.sub_feed.auth_token = BEARER_TOKEN
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.extend((&#34;posts&#34;, &#34;subscriptions&#34;, &#34;subscribers&#34;, &#39;comments&#39;, &#39;guests&#39;, &#39;blocked&#39;,
                                            &#39;smiles&#39;, &#39;sub_feed&#39;))
        
    def reload(self):
        self.__init__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ifunny_lib.Account.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(self):
    self.__init__()</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Account.update_attributes"><code class="name flex">
<span>def <span class="ident">update_attributes</span></span>(<span>self, data:dict=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_attributes(self, data: dict = None):

    if not data:
        cdata = self.cdata
    else:
        cdata = data
        self.cdata = cdata
    self.try_store_attribute(&#34;about&#34;, &#34;about&#34;)
    self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
    self.try_store_attribute(&#34;name&#34;, &#34;nick&#34;)
    self.try_store_attribute(&#39;stats&#39;, &#34;num&#34;)
    self.try_store_attribute(&#34;web_url&#34;, &#34;web_url&#34;)
    try:
        self.days = cdata[&#39;meme_experience&#39;][&#39;days&#39;]
    except KeyError:
        self.errored_attributes.append(&#34;days&#34;)
    try:
        self.endpoints = {&#34;main&#34;: f&#34;https://api.ifunny.mobi/v4/account&#34;,
                          &#39;posts&#39;: f&#39;https://api.ifunny.mobi/v4/timelines/users/&#39; + self.id,
                          &#39;subscriptions&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscriptions&#34;,
                          &#39;subscribers&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscribers&#34;,
                          &#39;comments&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/comments&#34;,  # Comment objects
                          &#39;guests&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/guests&#34;,  # User objects
                          &#39;blocked&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/blocked&#34;,  # User objects
                          &#39;smiles&#39;: f&#34;https://api.ifunny.mobi/v4/users/my/content_smiles&#34;,  # Post objects
                          &#39;sub_feed&#39;: f&#34;https://api.ifunny.mobi/v4/timelines/home&#34;}  # current sub feed
        self.posts = Queue(Post, self.endpoints[&#39;posts&#39;])
        self.subscriptions = Queue(User, self.endpoints[&#39;subscriptions&#39;])
        self.subscribers = Queue(User, self.endpoints[&#39;subscribers&#39;])
        self.comments = Queue(Comment, self.endpoints[&#39;comments&#39;])
        self.guests = Queue(User, self.endpoints[&#39;guests&#39;])  # will load 1 less than specified fixme
        self.blocked = Queue(User, self.endpoints[&#39;blocked&#39;])
        self.smiles = Queue(Post, self.endpoints[&#39;smiles&#39;])
        self.sub_feed = Queue(Post, self.endpoints[&#39;sub_feed&#39;])
        # these need the bearer auth to work
        self.comments.auth_token = BEARER_TOKEN
        self.guests.auth_token = BEARER_TOKEN
        self.blocked.auth_token = BEARER_TOKEN
        self.smiles.auth_token = BEARER_TOKEN
        self.sub_feed.auth_token = BEARER_TOKEN
    except AttributeError:
        self.errored_attributes.append(&#34;endpoints&#34;)
        self.errored_attributes.extend((&#34;posts&#34;, &#34;subscriptions&#34;, &#34;subscribers&#34;, &#39;comments&#39;, &#39;guests&#39;, &#39;blocked&#39;,
                                        &#39;smiles&#39;, &#39;sub_feed&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></b></code>:
<ul class="hlist">
<li><code><a title="ifunny_lib.IfBase.load_data" href="#ifunny_lib.IfBase.load_data">load_data</a></code></li>
<li><code><a title="ifunny_lib.IfBase.load_file_full" href="#ifunny_lib.IfBase.load_file_full">load_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.store_file_full" href="#ifunny_lib.IfBase.store_file_full">store_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.try_store_attribute" href="#ifunny_lib.IfBase.try_store_attribute">try_store_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ifunny_lib.Comment"><code class="flex name class">
<span>class <span class="ident">Comment</span></span>
<span>(</span><span>post_id:str=None, comment_id:str=None, data:dict=None, file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a single comment for easier parsing</p>
<p>Args are only used to find comment, internal vars are updated on their own.
post_id and comment_id are used to directly pull comment info
raw_data is the entire json that holds the comment data
cdata (cleaned data) is raw_data but stripped of the ['data']['comment'] keys
only need post_id &amp; comment_id or raw_data or cdata. The 'text' tag will contain the text or link to picture
comment, but defaults to only text if both are present.
:param post_id: post id string
:param comment_id: comment id string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Comment(IfBase):
    &#34;&#34;&#34;
    This is a single comment for easier parsing
    &#34;&#34;&#34;

    def __init__(self, post_id: str = None, comment_id: str = None, data: dict = None, file_name: str = None):
        &#34;&#34;&#34;
        Args are only used to find comment, internal vars are updated on their own.
        post_id and comment_id are used to directly pull comment info
        raw_data is the entire json that holds the comment data
        cdata (cleaned data) is raw_data but stripped of the [&#39;data&#39;][&#39;comment&#39;] keys
        only need post_id &amp; comment_id or raw_data or cdata. The &#39;text&#39; tag will contain the text or link to picture
        comment, but defaults to only text if both are present.
        :param post_id: post id string
        :param comment_id: comment id string
        &#34;&#34;&#34;

        logger.info(&#34;Comment/Reply object created&#34;)

        super().__init__(file_name)
        self.data_attributes.extend((&#34;smiles&#34;, &#39;replies&#39;))

        if file_name:
            pass
        else:
            self.load_file(file_name)
        if post_id and comment_id:
            data = api_call(f&#39;https://api.ifunny.mobi/v4/content/{post_id}/comments/{comment_id}&#39;,
                            auth=BASIC_TOKEN)
            self.cdata = self._data_cleaner(data)
        elif data:
            self.cdata = self._data_cleaner(data)
        elif not any((post_id, comment_id, data, file_name)):
            raise ValueError(&#34;need args&#34;)

        self.update_attributes()

        if not file_name and &#34;id&#34; not in self.errored_attributes:
            self.file_name = self.id + &#34;_&#34; + self.file_name

    def update_attributes(self, data=None):
        &#34;&#34;&#34;
        Use the current self.cdata to update all the current atrributes
        :return:
        &#34;&#34;&#34;

        if not data:
            cdata = self.cdata
        else:
            cdata = self._data_cleaner(data)
            self.cdata = data
        self.errored_attributes = []
        self.try_store_attribute(&#34;post_id&#34;, &#34;cid&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
        self.try_store_attribute(&#34;text&#34;, &#34;text&#34;)
        try:
            self.creator_id = cdata[&#39;user&#39;][&#39;id&#39;]
            self.creator_name = cdata[&#39;user&#39;][&#39;original_nick&#39;]
        except KeyError:
            self.errored_attributes.append(&#34;creator_id&#34;)
            self.errored_attributes.append(&#34;creator_name&#34;)
        try:
            self.endpoints = {&#39;main&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}&#39;,
                              &#39;replies&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}/replies&#39;,
                              &#39;smiles&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}/smiles&#39;}
            self.replies = Queue(Reply, self.endpoints[&#39;replies&#39;])
            self.smiles = Queue(User, self.endpoints[&#39;smiles&#39;])
            self.smiles.auth_token = BEARER_TOKEN  # getting who smiled comment/reply requires bearer for what ever reason
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.append(&#34;replies&#34;)
            self.errored_attributes.append(&#34;smiles&#34;)

    def _data_cleaner(self, var):
        # this returns a cleaned dict after striping the output it deems unneeded
        # this one was made for posts and needs to be calibrated
        if type(var) == dict:
            if &#34;error&#34; in var and &#34;not_found&#34; == var[&#39;error&#39;]:
                raise NoContent()
            if &#34;id&#34; in var:
                return var
            elif &#34;data&#34; in var:
                return var[&#34;data&#34;][&#34;comment&#34;]
        elif type(var) == list:
            return var[0]
        pprint(var)
        print(&#34;cleaner failed to find key&#34;)
        raise KeyError
    
    def reload(self):
        self.__init__(self.post_id, self.id)

    def add_reply(self, thing):
        &#34;&#34;&#34;
        Simple way to add a direct reply
        :param thing: reply object
        :return: None
        &#34;&#34;&#34;
        self.replies.store(thing)
        return self

    def get_id_object(self, id_to_check: str):
        &#34;&#34;&#34;
        Will return the reply object with the id.
        :param id_to_check: the id of the object
        :return: Reply object if found, else None
        &#34;&#34;&#34;
        if id_to_check == self.id:
            return self
        else:
            for a in self.replies:
                check_in = a.get_id_object(id_to_check=id_to_check)
                if check_in is not None:
                    return check_in
            return None

    def nest_replies(self):
        &#34;&#34;&#34;
        Take the replies stared in self.replies and properly nest them.
        :return: self
        &#34;&#34;&#34;

        temp_stored_content = []
        for a in self.replies.stored_content:
            found = False
            for b in temp_stored_content:
                target = b.get_id_object(a.parent_comment_id)
                if target is None:
                    continue
                target.add_reply(a)
                found = True
            if not found:
                temp_stored_content.append(a)
        self.replies.stored_content = temp_stored_content
        return self

    def tree_cdata(self) -&gt; tuple:
        &#34;&#34;&#34;
        Like id_tree, but this one returns all the cdata instead of only ids
        :return: cdata in nested form
        &#34;&#34;&#34;

        reply_list = []
        for a in self.replies:
            # todo remove this limiter
            sanity = a.tree()
            if &#34;last_reply&#34; in sanity[0]:
                del sanity[0][&#34;last_reply&#34;]
            reply_list.append(sanity)
        return self.cdata, reply_list</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ifunny_lib.Reply" href="#ifunny_lib.Reply">Reply</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ifunny_lib.Comment.add_reply"><code class="name flex">
<span>def <span class="ident">add_reply</span></span>(<span>self, thing)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple way to add a direct reply
:param thing: reply object
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_reply(self, thing):
    &#34;&#34;&#34;
    Simple way to add a direct reply
    :param thing: reply object
    :return: None
    &#34;&#34;&#34;
    self.replies.store(thing)
    return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Comment.get_id_object"><code class="name flex">
<span>def <span class="ident">get_id_object</span></span>(<span>self, id_to_check:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Will return the reply object with the id.
:param id_to_check: the id of the object
:return: Reply object if found, else None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_object(self, id_to_check: str):
    &#34;&#34;&#34;
    Will return the reply object with the id.
    :param id_to_check: the id of the object
    :return: Reply object if found, else None
    &#34;&#34;&#34;
    if id_to_check == self.id:
        return self
    else:
        for a in self.replies:
            check_in = a.get_id_object(id_to_check=id_to_check)
            if check_in is not None:
                return check_in
        return None</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Comment.nest_replies"><code class="name flex">
<span>def <span class="ident">nest_replies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Take the replies stared in self.replies and properly nest them.
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nest_replies(self):
    &#34;&#34;&#34;
    Take the replies stared in self.replies and properly nest them.
    :return: self
    &#34;&#34;&#34;

    temp_stored_content = []
    for a in self.replies.stored_content:
        found = False
        for b in temp_stored_content:
            target = b.get_id_object(a.parent_comment_id)
            if target is None:
                continue
            target.add_reply(a)
            found = True
        if not found:
            temp_stored_content.append(a)
    self.replies.stored_content = temp_stored_content
    return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Comment.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(self):
    self.__init__(self.post_id, self.id)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Comment.tree_cdata"><code class="name flex">
<span>def <span class="ident">tree_cdata</span></span>(<span>self) >tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Like id_tree, but this one returns all the cdata instead of only ids
:return: cdata in nested form</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree_cdata(self) -&gt; tuple:
    &#34;&#34;&#34;
    Like id_tree, but this one returns all the cdata instead of only ids
    :return: cdata in nested form
    &#34;&#34;&#34;

    reply_list = []
    for a in self.replies:
        # todo remove this limiter
        sanity = a.tree()
        if &#34;last_reply&#34; in sanity[0]:
            del sanity[0][&#34;last_reply&#34;]
        reply_list.append(sanity)
    return self.cdata, reply_list</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Comment.update_attributes"><code class="name flex">
<span>def <span class="ident">update_attributes</span></span>(<span>self, data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Use the current self.cdata to update all the current atrributes
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_attributes(self, data=None):
    &#34;&#34;&#34;
    Use the current self.cdata to update all the current atrributes
    :return:
    &#34;&#34;&#34;

    if not data:
        cdata = self.cdata
    else:
        cdata = self._data_cleaner(data)
        self.cdata = data
    self.errored_attributes = []
    self.try_store_attribute(&#34;post_id&#34;, &#34;cid&#34;)
    self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
    self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
    self.try_store_attribute(&#34;text&#34;, &#34;text&#34;)
    try:
        self.creator_id = cdata[&#39;user&#39;][&#39;id&#39;]
        self.creator_name = cdata[&#39;user&#39;][&#39;original_nick&#39;]
    except KeyError:
        self.errored_attributes.append(&#34;creator_id&#34;)
        self.errored_attributes.append(&#34;creator_name&#34;)
    try:
        self.endpoints = {&#39;main&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}&#39;,
                          &#39;replies&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}/replies&#39;,
                          &#39;smiles&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.post_id}/comments/{self.id}/smiles&#39;}
        self.replies = Queue(Reply, self.endpoints[&#39;replies&#39;])
        self.smiles = Queue(User, self.endpoints[&#39;smiles&#39;])
        self.smiles.auth_token = BEARER_TOKEN  # getting who smiled comment/reply requires bearer for what ever reason
    except AttributeError:
        self.errored_attributes.append(&#34;endpoints&#34;)
        self.errored_attributes.append(&#34;replies&#34;)
        self.errored_attributes.append(&#34;smiles&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></b></code>:
<ul class="hlist">
<li><code><a title="ifunny_lib.IfBase.load_data" href="#ifunny_lib.IfBase.load_data">load_data</a></code></li>
<li><code><a title="ifunny_lib.IfBase.load_file_full" href="#ifunny_lib.IfBase.load_file_full">load_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.store_file_full" href="#ifunny_lib.IfBase.store_file_full">store_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.try_store_attribute" href="#ifunny_lib.IfBase.try_store_attribute">try_store_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ifunny_lib.IfBase"><code class="flex name class">
<span>class <span class="ident">IfBase</span></span>
<span>(</span><span>file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IfBase:

    def __init__(self, file_name: str = None):
        try:
            self.cdata = self.__getattribute__(&#34;cdata&#34;)
        except AttributeError:
            self.cdata = {}

        self.errored_attributes = set()
        self.data_attributes = [&#34;cdata&#34;, &#39;errored_attributes&#39;]
        if not file_name:
            self.file_name = str(datetime.datetime.now().strftime(&#34;%Y%m%d-%H%M%S&#34;))
        else:
            self.file_name = str(file_name)
        # print(type(str(self.file_name)))

    def store_file_full(self, name: str = None):
        &#34;&#34;&#34;Uses alternative method to store all of object data. Maybe works a panic option.
        :param name: File name/path to open
        &#34;&#34;&#34;
        if not name:
            name = self.file_name
        with open(name, &#39;wb&#39;) as f:
            pickle.dump(self, f)
        logger.debug(&#34;Full store&#34;)

    def load_file_full(self, name: str):
        &#34;&#34;&#34;Uses alternative method to store all of object data. Maybe works a panic option.
        :param name: File name/path to open
        &#34;&#34;&#34;
        if not name:
            name = self.file_name
        with open(name, &#39;rb&#39;) as f:
            data = pickle.load(f)
            print(data.__dict__[&#39;smiles&#39;])
            self.__dict__ = copy.deepcopy(data.__dict__)
        logger.debug(&#34;Full load&#34;)

    def store_file(self, name: str = None):
        if not name:
            name = self.file_name
        with open(name, &#39;wb&#39;) as f:
            data = [self.__getattribute__(a) for a in self.data_attributes]
            pickle.dump(data, f)

    def load_file(self, name: str):
        if not name:
            name = self.file_name
        with open(name, &#34;rb&#34;) as f:
            data = pickle.load(f)
            for num_a, a in enumerate(data):
                if type(a) == Queue:
                    logger.debug(num_a, self.data_attributes[num_a], a.stored_content)
                self.__setattr__(self.data_attributes[num_a], a)

    def load_data(self, data: dict):
        &#34;&#34;&#34;
        Probably unnecessary
        &#34;&#34;&#34;
        self.cdata = data

    def try_store_attribute(self, name: str, val: str):
        &#34;&#34;&#34;
        Try to clean up the constant try-excepting
        &#34;&#34;&#34;
        try:
            self.__setattr__(name, self.cdata[val])
        except KeyError:
            self.errored_attributes.add(name)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ifunny_lib.Account" href="#ifunny_lib.Account">Account</a></li>
<li><a title="ifunny_lib.Comment" href="#ifunny_lib.Comment">Comment</a></li>
<li><a title="ifunny_lib.Post" href="#ifunny_lib.Post">Post</a></li>
<li><a title="ifunny_lib.User" href="#ifunny_lib.User">User</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ifunny_lib.IfBase.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, data:dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Probably unnecessary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(self, data: dict):
    &#34;&#34;&#34;
    Probably unnecessary
    &#34;&#34;&#34;
    self.cdata = data</code></pre>
</details>
</dd>
<dt id="ifunny_lib.IfBase.load_file"><code class="name flex">
<span>def <span class="ident">load_file</span></span>(<span>self, name:str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_file(self, name: str):
    if not name:
        name = self.file_name
    with open(name, &#34;rb&#34;) as f:
        data = pickle.load(f)
        for num_a, a in enumerate(data):
            if type(a) == Queue:
                logger.debug(num_a, self.data_attributes[num_a], a.stored_content)
            self.__setattr__(self.data_attributes[num_a], a)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.IfBase.load_file_full"><code class="name flex">
<span>def <span class="ident">load_file_full</span></span>(<span>self, name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses alternative method to store all of object data. Maybe works a panic option.
:param name: File name/path to open</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_file_full(self, name: str):
    &#34;&#34;&#34;Uses alternative method to store all of object data. Maybe works a panic option.
    :param name: File name/path to open
    &#34;&#34;&#34;
    if not name:
        name = self.file_name
    with open(name, &#39;rb&#39;) as f:
        data = pickle.load(f)
        print(data.__dict__[&#39;smiles&#39;])
        self.__dict__ = copy.deepcopy(data.__dict__)
    logger.debug(&#34;Full load&#34;)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.IfBase.store_file"><code class="name flex">
<span>def <span class="ident">store_file</span></span>(<span>self, name:str=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_file(self, name: str = None):
    if not name:
        name = self.file_name
    with open(name, &#39;wb&#39;) as f:
        data = [self.__getattribute__(a) for a in self.data_attributes]
        pickle.dump(data, f)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.IfBase.store_file_full"><code class="name flex">
<span>def <span class="ident">store_file_full</span></span>(<span>self, name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses alternative method to store all of object data. Maybe works a panic option.
:param name: File name/path to open</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_file_full(self, name: str = None):
    &#34;&#34;&#34;Uses alternative method to store all of object data. Maybe works a panic option.
    :param name: File name/path to open
    &#34;&#34;&#34;
    if not name:
        name = self.file_name
    with open(name, &#39;wb&#39;) as f:
        pickle.dump(self, f)
    logger.debug(&#34;Full store&#34;)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.IfBase.try_store_attribute"><code class="name flex">
<span>def <span class="ident">try_store_attribute</span></span>(<span>self, name:str, val:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to clean up the constant try-excepting</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_store_attribute(self, name: str, val: str):
    &#34;&#34;&#34;
    Try to clean up the constant try-excepting
    &#34;&#34;&#34;
    try:
        self.__setattr__(name, self.cdata[val])
    except KeyError:
        self.errored_attributes.add(name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ifunny_lib.MissingAuthToken"><code class="flex name class">
<span>class <span class="ident">MissingAuthToken</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exists only to tell the user that load_auths() has not been run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingAuthToken(Exception):
    &#34;&#34;&#34;
    Exists only to tell the user that load_auths() has not been run.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ifunny_lib.NoContent"><code class="flex name class">
<span>class <span class="ident">NoContent</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>There was an error when searching for the content and the api returned an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoContent(Exception):
    &#34;&#34;&#34;
    There was an error when searching for the content and the api returned an error.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ifunny_lib.Post"><code class="flex name class">
<span>class <span class="ident">Post</span></span>
<span>(</span><span>post_id:str=None, data:dict=None, file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This holds a single post, and parses the data for more easy use.</p>
<p>post_id is the direct way to call post json info
:param post_id: post id string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Post(IfBase):
    &#34;&#34;&#34;
    This holds a single post, and parses the data for more easy use.
    &#34;&#34;&#34;

    def __init__(self, post_id: str = None, data: dict = None, file_name: str = None):
        &#34;&#34;&#34;
        post_id is the direct way to call post json info
        :param post_id: post id string
        &#34;&#34;&#34;
        logger.info(&#34;Post object created&#34;)

        super().__init__(file_name)
        self.data_attributes.extend((&#39;comments&#39;, &#39;repubs&#39;, &#39;smiles&#39;))

        if file_name:
            self.load_file(file_name)
        else:
            if post_id:
                data = api_call(&#34;https://api.ifunny.mobi/v4/content/&#34; + post_id, auth=BASIC_TOKEN)
                # print(data)
                self.cdata = self._data_cleaner(data)
                # print(self.cdata)
            elif data:
                self.cdata = self._data_cleaner(data)
            elif not any((post_id, data, file_name)):
                raise ValueError(&#34;need args&#34;)

            self.update_attributes()

            if &#34;id&#34; not in self.errored_attributes:
                self.file_name = self.id + &#34;_&#34; + self.file_name


    def update_attributes(self, data: dict = None):

        if not data:
            cdata = self.cdata
        else:
            cdata = data
            self.cdata = cdata

        self.errored_attributes = []
        try:
            self.creator_id = cdata[&#34;creator&#34;][&#34;id&#34;]
            self.creator_name = cdata[&#34;creator&#34;][&#34;original_nick&#34;]  # uses original name for consistency over time hopefully
        except KeyError:
            self.errored_attributes.append(&#34;creator_id&#34;)
            self.errored_attributes.append(&#34;creator_name&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;link&#34;, &#34;link&#34;)
        self.try_store_attribute(&#34;url&#34;, &#34;url&#34;)
        self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
        self.try_store_attribute(&#34;type&#34;, &#34;type&#34;)
        # if self.endpoints fails, so will all the queues
        try:
            self.endpoints = {&#39;main&#39;: &#34;https://api.ifunny.mobi/v4/content/&#34; + self.id,
                              &#39;comments&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/comments&#39;,
                              &#39;repubs&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/republished&#39;,
                              &#39;smiles&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/smiles&#39;}
            self.comments = Queue(Comment, self.endpoints[&#39;comments&#39;])
            self.repubs = Queue(User, self.endpoints[&#39;repubs&#39;])
            self.smiles = Queue(User, self.endpoints[&#39;smiles&#39;])
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.append(&#34;comments&#34;)
            self.errored_attributes.append(&#34;repubs&#34;)
            self.errored_attributes.append(&#34;smiles&#34;)

    def _data_cleaner(self, var):
        # this returns a cleaned dict after striping the output it deems unneeded. Also only returns first object if given a list

        # print(var)
        if type(var) == dict:
            if &#34;error&#34; in var and &#34;not_found&#34; == var[&#39;error&#39;]:
                raise NoContent
            if &#34;id&#34; in var:
                return var
            elif &#34;data&#34; in var:
                if &#34;id&#34; in var[&#34;data&#34;]:
                    logger.info(var)
                    return var[&#34;data&#34;]
                return var[&#34;data&#34;][&#39;content&#39;][&#39;items&#39;][0]
        elif type(var) == list:
            return self._data_cleaner(var[0])

        print(var)
        print(&#34;cleaner failed to find key&#34;)
        raise KeyError
    
    def reload(self):
        self.__init__(self.id)

    def add_comment(self, thing):
        self.comments.store(thing)
        return self

    def load_comment_tree(self, comments: int = None, reply_limit: int = None):
        &#34;&#34;&#34;
        I don&#39;t want load functions, but this one is more complex so it gets to stay.
        :param comments: How many comments to try to load
        :param reply_limit: How many relpies to each comment loaded
        :return: None
        &#34;&#34;&#34;
        self.comments.load(limit=comments)
        for a in self.comments:
            a.replies.load(reply_limit)
            a.nest_replies()
        return self

    def comment_tree(self) -&gt; list:
        reply_list = []
        for a in self.comments:
            reply_list.append(a.tree())
        return reply_list

    def get_id_object(self, id_to_check: str):
        &#34;&#34;&#34;
        Searches for id within the nested comments.
        :param id_to_check: Doesn&#39;t care about the class will just get its id.
        :return:
        &#34;&#34;&#34;
        # pprint(self.cdata)
        if id_to_check == self.id:
            return self
        else:
            for a in self.comments:
                check_in = a.get_id_object(id_to_check=id_to_check)
                if check_in is not None:
                    return check_in
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ifunny_lib.Post.add_comment"><code class="name flex">
<span>def <span class="ident">add_comment</span></span>(<span>self, thing)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_comment(self, thing):
    self.comments.store(thing)
    return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Post.comment_tree"><code class="name flex">
<span>def <span class="ident">comment_tree</span></span>(<span>self) >list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comment_tree(self) -&gt; list:
    reply_list = []
    for a in self.comments:
        reply_list.append(a.tree())
    return reply_list</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Post.get_id_object"><code class="name flex">
<span>def <span class="ident">get_id_object</span></span>(<span>self, id_to_check:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for id within the nested comments.
:param id_to_check: Doesn't care about the class will just get its id.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id_object(self, id_to_check: str):
    &#34;&#34;&#34;
    Searches for id within the nested comments.
    :param id_to_check: Doesn&#39;t care about the class will just get its id.
    :return:
    &#34;&#34;&#34;
    # pprint(self.cdata)
    if id_to_check == self.id:
        return self
    else:
        for a in self.comments:
            check_in = a.get_id_object(id_to_check=id_to_check)
            if check_in is not None:
                return check_in
        return None</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Post.load_comment_tree"><code class="name flex">
<span>def <span class="ident">load_comment_tree</span></span>(<span>self, comments:int=None, reply_limit:int=None)</span>
</code></dt>
<dd>
<div class="desc"><p>I don't want load functions, but this one is more complex so it gets to stay.
:param comments: How many comments to try to load
:param reply_limit: How many relpies to each comment loaded
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_comment_tree(self, comments: int = None, reply_limit: int = None):
    &#34;&#34;&#34;
    I don&#39;t want load functions, but this one is more complex so it gets to stay.
    :param comments: How many comments to try to load
    :param reply_limit: How many relpies to each comment loaded
    :return: None
    &#34;&#34;&#34;
    self.comments.load(limit=comments)
    for a in self.comments:
        a.replies.load(reply_limit)
        a.nest_replies()
    return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Post.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(self):
    self.__init__(self.id)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Post.update_attributes"><code class="name flex">
<span>def <span class="ident">update_attributes</span></span>(<span>self, data:dict=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_attributes(self, data: dict = None):

    if not data:
        cdata = self.cdata
    else:
        cdata = data
        self.cdata = cdata

    self.errored_attributes = []
    try:
        self.creator_id = cdata[&#34;creator&#34;][&#34;id&#34;]
        self.creator_name = cdata[&#34;creator&#34;][&#34;original_nick&#34;]  # uses original name for consistency over time hopefully
    except KeyError:
        self.errored_attributes.append(&#34;creator_id&#34;)
        self.errored_attributes.append(&#34;creator_name&#34;)
    self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
    self.try_store_attribute(&#34;link&#34;, &#34;link&#34;)
    self.try_store_attribute(&#34;url&#34;, &#34;url&#34;)
    self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
    self.try_store_attribute(&#34;type&#34;, &#34;type&#34;)
    # if self.endpoints fails, so will all the queues
    try:
        self.endpoints = {&#39;main&#39;: &#34;https://api.ifunny.mobi/v4/content/&#34; + self.id,
                          &#39;comments&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/comments&#39;,
                          &#39;repubs&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/republished&#39;,
                          &#39;smiles&#39;: f&#39;https://api.ifunny.mobi/v4/content/{self.id}/smiles&#39;}
        self.comments = Queue(Comment, self.endpoints[&#39;comments&#39;])
        self.repubs = Queue(User, self.endpoints[&#39;repubs&#39;])
        self.smiles = Queue(User, self.endpoints[&#39;smiles&#39;])
    except AttributeError:
        self.errored_attributes.append(&#34;endpoints&#34;)
        self.errored_attributes.append(&#34;comments&#34;)
        self.errored_attributes.append(&#34;repubs&#34;)
        self.errored_attributes.append(&#34;smiles&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></b></code>:
<ul class="hlist">
<li><code><a title="ifunny_lib.IfBase.load_data" href="#ifunny_lib.IfBase.load_data">load_data</a></code></li>
<li><code><a title="ifunny_lib.IfBase.load_file_full" href="#ifunny_lib.IfBase.load_file_full">load_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.store_file_full" href="#ifunny_lib.IfBase.store_file_full">store_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.try_store_attribute" href="#ifunny_lib.IfBase.try_store_attribute">try_store_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ifunny_lib.Queue"><code class="flex name class">
<span>class <span class="ident">Queue</span></span>
<span>(</span><span>stored_class_type:type=None, source_url:str=None, tag_only_mode:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is to store queues such as post a user has, replies a post has, etc.
not all list functions are implemented. If not, use it on Queue.stored_content as that is the basis.</p>
<p>The init method which prepares the class. The auth needs to be changed from outside if it doesn't use basic.
:param stored_class_type: What Type of object that is going to be stored such as User, Post, Comment.
:param source_url: What endpoint is going to be used.
:param tag_only_mode: If given, it will only store that attribute from the data in the list
:param force_load: force load from id to ensure consistency of content. May lose or gain data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Queue:
    &#34;&#34;&#34;
    This is to store queues such as post a user has, replies a post has, etc.
    not all list functions are implemented. If not, use it on Queue.stored_content as that is the basis.
    &#34;&#34;&#34;

    def __init__(self, stored_class_type: type = None, source_url: str = None, tag_only_mode: str = None):
        &#34;&#34;&#34;
        The init method which prepares the class. The auth needs to be changed from outside if it doesn&#39;t use basic.
        :param stored_class_type: What Type of object that is going to be stored such as User, Post, Comment.
        :param source_url: What endpoint is going to be used.
        :param tag_only_mode: If given, it will only store that attribute from the data in the list
        :param force_load: force load from id to ensure consistency of content. May lose or gain data.
        &#34;&#34;&#34;
        # todo maybe make this inheret from list to give more functionality via __*__

        logger.info(&#34;Queue object created&#34;)

        if source_url is None:
            raise ValueError(&#34;Missing arg&#34;)
        self.stored_class_type = stored_class_type
        self.source_url = source_url
        self.tag_only_mode = tag_only_mode  # setting this to false before loading anything will may decrease server load and avoid making mare object
        self.stored_content = []  # this is just a list of the objects Queue just makes loading them easier
        self.page_next = None
        self.has_next = True
        self.chunks = 100  # this can be changed as an option but is set to max size for max speed
        self.auth_token = BASIC_TOKEN

    def __iter__(self):
        return (t for t in self.stored_content)

    def __getitem__(self, item):
        return self.stored_content[item]

    def __len__(self):
        return len(self.stored_content)

    def __str__(self):
        return str(self.stored_content)

    def store(self, thing):
        &#34;&#34;&#34;
        A single word way to store a piece of data.
        &#34;&#34;&#34;
        self.stored_content.append(thing)
        return self

    def clear(self):
        &#34;&#34;&#34;
        This resets the stored content if called for any reason.
        &#34;&#34;&#34;
        self.stored_content = []
        self.page_next = None
        self.has_next = True
        return self

    def queue_data_cleaner(self, var):
        &#34;&#34;&#34;
        Hopefully a universal data cleaner that strips unwanted data.
        &#34;&#34;&#34;
        # this returns a cleaned dict after striping the output it deems unneeded and should return a list
        # this one was made for posts nad needs to be calibrated
        if type(var) == list:
            if len(var) &gt; 0 and &#34;guest&#34; in var[0]:
                return [a[&#39;guest&#39;] for a in var]
            return var
        elif type(var) == dict:
            if &#34;items&#34; in var:
                return self.queue_data_cleaner(var[&#34;items&#34;])
            elif &#34;comments&#34; in var:
                return self.queue_data_cleaner(var[&#34;comments&#34;])
            elif &#34;replies&#34; in var:
                return self.queue_data_cleaner(var[&#34;replies&#34;])
            elif &#34;content&#34; in var:
                return self.queue_data_cleaner(var[&#34;content&#34;])
            elif &#34;data&#34; in var:
                return self.queue_data_cleaner(var[&#34;data&#34;])
            elif &#34;id&#34; in var:
                return [var]
            elif &#34;users&#34; in var:
                return self.queue_data_cleaner(var[&#34;users&#34;])
            elif &#34;guests&#34; in var:
                return self.queue_data_cleaner(var[&#39;guests&#39;])
        pprint(var)
        pprint(self.source_url)
        raise KeyError(&#34;failed to find key&#34;)

    def page_info(self, var):
        if type(var) != dict:
            return
        if &#34;paging&#34; in var:
            return var[&#34;paging&#34;]
        else:
            for k in var.keys():
                found = self.page_info(var[k])
                if found:
                    return found
        raise KeyError(&#34;No &#39;paging&#39; key found&#34;)

    def load(self, limit: int = None, paging_start: str = None):
        &#34;&#34;&#34;
        I want to do this in chunks of 100 so we get data as fast as possible. When limit == None we load until no more
        if limit == 0 then we return a clean Queue object.
        force_load does nothing right now, am considering giving the option to recall all obects by id to ensure all data is stored
        :param limit: How many to load
        :param paging_start: Changes the loading start point
        :return: self
        &#34;&#34;&#34;
        if limit == 0:
            # dumb shit may possible here without the check
            return

        if self.source_url == &#34;https://api.ifunny.mobi/v4/users/my/guests&#34;:
            limit += 1

        while self.has_next:
            if not limit or limit &gt; self.chunks:
                response = api_call(self.source_url, auth=self.auth_token, params={&#39;next&#39;: paging_start, &#39;limit&#39;: self.chunks}, method=&#34;GET&#34; if self.source_url != &#34;https://api.ifunny.mobi/v4/feeds/collective&#34; else &#34;POST&#34;)
            #     do parse and store
            else:
                response = api_call(self.source_url, auth=self.auth_token, params={&#39;next&#39;: paging_start, &#39;limit&#39;: limit})
            # pprint(response)
            pure_list = self.queue_data_cleaner(response)
            if self.tag_only_mode:
                for a in pure_list:
                    self.store(a[self.tag_only_mode])
            elif self.stored_class_type is None:
                for a in pure_list:
                    self.store(a)
            elif self.stored_class_type == Post:
                for a in pure_list:
                    self.store(Post(data=a))
            elif self.stored_class_type == Comment:
                for a in pure_list:
                    self.store(Comment(data=a))
            elif self.stored_class_type == Reply:
                for a in pure_list:
                    self.store(Reply(data=a))
            elif self.stored_class_type == User:
                for a in pure_list:
                    self.store(User(data=a))
            else:
                raise TypeError(&#34;type was not found&#34;)
            page_info = self.page_info(response)
            self.has_next = page_info[&#39;hasNext&#39;]
            # print(page_info)
            if self.has_next:
                paging_start = self.page_next = page_info[&#34;cursors&#34;][&#39;next&#39;]
            if limit:
                limit -= self.chunks
                if limit &lt;= 0:
                    return self

    def load_next(self, limit: int = 1):
        &#34;&#34;&#34;
        load the next posts after the current loaded ones
        limit == None will load until end,
        :param limit:
        :return: self
        &#34;&#34;&#34;
        self.load(limit, self.page_next)
        return self

    def load_until(self, ids: tuple = (), needed_matches: int = 1, include_matches: bool = True, emergency_limit: int = -1, clean_overflow: bool = True):
        &#34;&#34;&#34;
        This will load objects until enough matching id&#39;s are found. Ideally for loading until old content in found.
        &#34;&#34;&#34;
        pointer = 0  # shows what we are looking at in stored_content
        while needed_matches &gt; 0 and emergency_limit != 0:
            self.load_next(limit=self.chunks)
            for a in self.stored_content[pointer:]:
                if a.id in ids:
                    needed_matches -= 1
                    if not include_matches:
                        self.stored_content.remove(pointer)
                        pointer -= 1
                pointer += 1
            emergency_limit -= 1
        if clean_overflow:
            self.stored_content = self.stored_content[:min(pointer + 1, len(self.stored_content))]
        return self

    def save_to_file(self, file_name: str = None):
        if not file_name:
            file_name = str(self.stored_class_type).replace(&#34;&#39;&#34;, &#39;&#39;).replace(&#39;class&#39;, &#39;&#39;).replace(&#39; &#39;, &#39;&#39;).replace(&#39;ifunny_lib.&#39;, &#39;&#39;).replace(&#39;&lt;&#39;, &#39;&#39;).replace(&#39;&gt;&#39;, &#39;&#39;) + &#34;_queue&#34;
        if &#39;.txt&#39; not in file_name:
            file_name += &#39;.txt&#39;
        with open(file_name, &#39;w&#39;) as f:
            for a in self.stored_content:
                if type(a) == str:
                    f.write(a + &#39;\n&#39;)
                else:
                    f.write(str(a.cdata) + &#39;\n&#39;)

    def load_from_file(self, file_name: str):
        with open(file_name, &#39;r&#39;) as f:
            for a in f.readlines():
                self.store(self.stored_class_type(data=eval(a.strip())))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ifunny_lib.Queue.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This resets the stored content if called for any reason.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    This resets the stored content if called for any reason.
    &#34;&#34;&#34;
    self.stored_content = []
    self.page_next = None
    self.has_next = True
    return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, limit:int=None, paging_start:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>I want to do this in chunks of 100 so we get data as fast as possible. When limit == None we load until no more
if limit == 0 then we return a clean Queue object.
force_load does nothing right now, am considering giving the option to recall all obects by id to ensure all data is stored
:param limit: How many to load
:param paging_start: Changes the loading start point
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, limit: int = None, paging_start: str = None):
    &#34;&#34;&#34;
    I want to do this in chunks of 100 so we get data as fast as possible. When limit == None we load until no more
    if limit == 0 then we return a clean Queue object.
    force_load does nothing right now, am considering giving the option to recall all obects by id to ensure all data is stored
    :param limit: How many to load
    :param paging_start: Changes the loading start point
    :return: self
    &#34;&#34;&#34;
    if limit == 0:
        # dumb shit may possible here without the check
        return

    if self.source_url == &#34;https://api.ifunny.mobi/v4/users/my/guests&#34;:
        limit += 1

    while self.has_next:
        if not limit or limit &gt; self.chunks:
            response = api_call(self.source_url, auth=self.auth_token, params={&#39;next&#39;: paging_start, &#39;limit&#39;: self.chunks}, method=&#34;GET&#34; if self.source_url != &#34;https://api.ifunny.mobi/v4/feeds/collective&#34; else &#34;POST&#34;)
        #     do parse and store
        else:
            response = api_call(self.source_url, auth=self.auth_token, params={&#39;next&#39;: paging_start, &#39;limit&#39;: limit})
        # pprint(response)
        pure_list = self.queue_data_cleaner(response)
        if self.tag_only_mode:
            for a in pure_list:
                self.store(a[self.tag_only_mode])
        elif self.stored_class_type is None:
            for a in pure_list:
                self.store(a)
        elif self.stored_class_type == Post:
            for a in pure_list:
                self.store(Post(data=a))
        elif self.stored_class_type == Comment:
            for a in pure_list:
                self.store(Comment(data=a))
        elif self.stored_class_type == Reply:
            for a in pure_list:
                self.store(Reply(data=a))
        elif self.stored_class_type == User:
            for a in pure_list:
                self.store(User(data=a))
        else:
            raise TypeError(&#34;type was not found&#34;)
        page_info = self.page_info(response)
        self.has_next = page_info[&#39;hasNext&#39;]
        # print(page_info)
        if self.has_next:
            paging_start = self.page_next = page_info[&#34;cursors&#34;][&#39;next&#39;]
        if limit:
            limit -= self.chunks
            if limit &lt;= 0:
                return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.load_from_file"><code class="name flex">
<span>def <span class="ident">load_from_file</span></span>(<span>self, file_name:str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_file(self, file_name: str):
    with open(file_name, &#39;r&#39;) as f:
        for a in f.readlines():
            self.store(self.stored_class_type(data=eval(a.strip())))</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.load_next"><code class="name flex">
<span>def <span class="ident">load_next</span></span>(<span>self, limit:int=1)</span>
</code></dt>
<dd>
<div class="desc"><p>load the next posts after the current loaded ones
limit == None will load until end,
:param limit:
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_next(self, limit: int = 1):
    &#34;&#34;&#34;
    load the next posts after the current loaded ones
    limit == None will load until end,
    :param limit:
    :return: self
    &#34;&#34;&#34;
    self.load(limit, self.page_next)
    return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.load_until"><code class="name flex">
<span>def <span class="ident">load_until</span></span>(<span>self, ids:tuple=(), needed_matches:int=1, include_matches:bool=True, emergency_limit:int=-1, clean_overflow:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This will load objects until enough matching id's are found. Ideally for loading until old content in found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_until(self, ids: tuple = (), needed_matches: int = 1, include_matches: bool = True, emergency_limit: int = -1, clean_overflow: bool = True):
    &#34;&#34;&#34;
    This will load objects until enough matching id&#39;s are found. Ideally for loading until old content in found.
    &#34;&#34;&#34;
    pointer = 0  # shows what we are looking at in stored_content
    while needed_matches &gt; 0 and emergency_limit != 0:
        self.load_next(limit=self.chunks)
        for a in self.stored_content[pointer:]:
            if a.id in ids:
                needed_matches -= 1
                if not include_matches:
                    self.stored_content.remove(pointer)
                    pointer -= 1
            pointer += 1
        emergency_limit -= 1
    if clean_overflow:
        self.stored_content = self.stored_content[:min(pointer + 1, len(self.stored_content))]
    return self</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.page_info"><code class="name flex">
<span>def <span class="ident">page_info</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_info(self, var):
    if type(var) != dict:
        return
    if &#34;paging&#34; in var:
        return var[&#34;paging&#34;]
    else:
        for k in var.keys():
            found = self.page_info(var[k])
            if found:
                return found
    raise KeyError(&#34;No &#39;paging&#39; key found&#34;)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.queue_data_cleaner"><code class="name flex">
<span>def <span class="ident">queue_data_cleaner</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<div class="desc"><p>Hopefully a universal data cleaner that strips unwanted data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_data_cleaner(self, var):
    &#34;&#34;&#34;
    Hopefully a universal data cleaner that strips unwanted data.
    &#34;&#34;&#34;
    # this returns a cleaned dict after striping the output it deems unneeded and should return a list
    # this one was made for posts nad needs to be calibrated
    if type(var) == list:
        if len(var) &gt; 0 and &#34;guest&#34; in var[0]:
            return [a[&#39;guest&#39;] for a in var]
        return var
    elif type(var) == dict:
        if &#34;items&#34; in var:
            return self.queue_data_cleaner(var[&#34;items&#34;])
        elif &#34;comments&#34; in var:
            return self.queue_data_cleaner(var[&#34;comments&#34;])
        elif &#34;replies&#34; in var:
            return self.queue_data_cleaner(var[&#34;replies&#34;])
        elif &#34;content&#34; in var:
            return self.queue_data_cleaner(var[&#34;content&#34;])
        elif &#34;data&#34; in var:
            return self.queue_data_cleaner(var[&#34;data&#34;])
        elif &#34;id&#34; in var:
            return [var]
        elif &#34;users&#34; in var:
            return self.queue_data_cleaner(var[&#34;users&#34;])
        elif &#34;guests&#34; in var:
            return self.queue_data_cleaner(var[&#39;guests&#39;])
    pprint(var)
    pprint(self.source_url)
    raise KeyError(&#34;failed to find key&#34;)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.save_to_file"><code class="name flex">
<span>def <span class="ident">save_to_file</span></span>(<span>self, file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to_file(self, file_name: str = None):
    if not file_name:
        file_name = str(self.stored_class_type).replace(&#34;&#39;&#34;, &#39;&#39;).replace(&#39;class&#39;, &#39;&#39;).replace(&#39; &#39;, &#39;&#39;).replace(&#39;ifunny_lib.&#39;, &#39;&#39;).replace(&#39;&lt;&#39;, &#39;&#39;).replace(&#39;&gt;&#39;, &#39;&#39;) + &#34;_queue&#34;
    if &#39;.txt&#39; not in file_name:
        file_name += &#39;.txt&#39;
    with open(file_name, &#39;w&#39;) as f:
        for a in self.stored_content:
            if type(a) == str:
                f.write(a + &#39;\n&#39;)
            else:
                f.write(str(a.cdata) + &#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.Queue.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self, thing)</span>
</code></dt>
<dd>
<div class="desc"><p>A single word way to store a piece of data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store(self, thing):
    &#34;&#34;&#34;
    A single word way to store a piece of data.
    &#34;&#34;&#34;
    self.stored_content.append(thing)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ifunny_lib.Reply"><code class="flex name class">
<span>class <span class="ident">Reply</span></span>
<span>(</span><span>post_id:str=None, comment_id:str=None, data:dict=None, file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>While very simmilar to the comment object, there are a few new pieces of data that a reply has that needs te be stored</p>
<p>Works in the same way as the Comment class, this is just a special case</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reply(Comment):
    &#34;&#34;&#34;
    While very simmilar to the comment object, there are a few new pieces of data that a reply has that needs te be stored
    &#34;&#34;&#34;

    def __init__(self, post_id: str = None, comment_id: str = None, data: dict = None, file_name: str = None):
        &#34;&#34;&#34;
        Works in the same way as the Comment class, this is just a special case
        &#34;&#34;&#34;
        super().__init__(post_id, comment_id, data, file_name)  # this should also auto clean the data being passed and stored

        if not file_name:
            self.update_attributes()

    def update_attributes(self, data: dict = None):

        if data:
            self.cdata = self._data_cleaner(data)

        super().update_attributes()
        self.try_store_attribute(&#34;depth&#34;, &#34;depth&#34;)
        self.try_store_attribute(&#34;parent_comment_id&#34;, &#34;parent_comm_id&#34;)
        self.try_store_attribute(&#34;root_comment_id&#34;, &#34;root_comm_id&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ifunny_lib.Comment" href="#ifunny_lib.Comment">Comment</a></li>
<li><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ifunny_lib.Comment" href="#ifunny_lib.Comment">Comment</a></b></code>:
<ul class="hlist">
<li><code><a title="ifunny_lib.Comment.add_reply" href="#ifunny_lib.Comment.add_reply">add_reply</a></code></li>
<li><code><a title="ifunny_lib.Comment.get_id_object" href="#ifunny_lib.Comment.get_id_object">get_id_object</a></code></li>
<li><code><a title="ifunny_lib.Comment.load_data" href="#ifunny_lib.IfBase.load_data">load_data</a></code></li>
<li><code><a title="ifunny_lib.Comment.load_file_full" href="#ifunny_lib.IfBase.load_file_full">load_file_full</a></code></li>
<li><code><a title="ifunny_lib.Comment.nest_replies" href="#ifunny_lib.Comment.nest_replies">nest_replies</a></code></li>
<li><code><a title="ifunny_lib.Comment.store_file_full" href="#ifunny_lib.IfBase.store_file_full">store_file_full</a></code></li>
<li><code><a title="ifunny_lib.Comment.tree_cdata" href="#ifunny_lib.Comment.tree_cdata">tree_cdata</a></code></li>
<li><code><a title="ifunny_lib.Comment.try_store_attribute" href="#ifunny_lib.IfBase.try_store_attribute">try_store_attribute</a></code></li>
<li><code><a title="ifunny_lib.Comment.update_attributes" href="#ifunny_lib.Comment.update_attributes">update_attributes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ifunny_lib.User"><code class="flex name class">
<span>class <span class="ident">User</span></span>
<span>(</span><span>creator_id:str=None, data:dict=None, file_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This holds the user data and gets called at various different times. Just because data exists, it doesn't mean all data get loaded. May need to reload() to have all info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class User(IfBase):
    &#34;&#34;&#34;
    This holds the user data and gets called at various different times. Just because data exists, it doesn&#39;t mean all data get loaded. May need to reload() to have all info
    &#34;&#34;&#34;
    def __init__(self, creator_id: str = None, data: dict = None, file_name: str = None):
        logger.info(&#34;Creator object created&#34;)

        super().__init__(file_name)
        self.data_attributes.extend((&#39;posts&#39;, &#39;subscriptions&#39;, &#39;subscribers&#39;))

        if file_name:
            self.load_file(file_name)
        else:
            if creator_id:
                data = api_call(f&#34;https://api.ifunny.mobi/v4/users/&#34; + creator_id, auth=BASIC_TOKEN)
                cdata = self._data_cleaner(data)
                self.cdata = cdata
            if data:
                cdata = self._data_cleaner(data)
                self.cdata = cdata
            elif not any((creator_id, data, file_name)):
                raise ValueError(&#34;need args&#34;)

            self.update_attributes()

            if not file_name and &#34;id&#34; not in self.errored_attributes:
                self.file_name = self.id + &#34;_&#34; + self.file_name

    def update_attributes(self, data: dict = None):

        if not data:
            cdata = self.cdata
        else:
            cdata = self._data_cleaner(data)
            self.cdata = cdata

        self.errored_attributes = []

        try:
            self.days = cdata[&#34;meme_experience&#34;][&#34;days&#34;]
        except KeyError:
            self.errored_attributes.append(&#34;days&#34;)

        self.try_store_attribute(&#34;web_url&#34;, &#34;web_url&#34;)
        self.try_store_attribute(&#34;about&#34;, &#34;about&#34;)
        self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
        self.try_store_attribute(&#34;name&#34;, &#34;nick&#34;)
        self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
        self.try_store_attribute(&#34;total_posts&#34;, &#34;total_posts&#34;)
        try:
            self.endpoints = {&#34;main&#34;: f&#34;https://api.ifunny.mobi/v4/account&#34;,
                              &#39;posts&#39;: f&#39;https://api.ifunny.mobi/v4/timelines/users/&#39; + self.id,
                              &#39;subscriptions&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscriptions&#34;,
                              &#39;subscribers&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscribers&#34;}
            self.posts = Queue(Post, self.endpoints[&#39;posts&#39;])
            self.subscriptions = Queue(User, self.endpoints[&#39;subscriptions&#39;])
            self.subscribers = Queue(User, self.endpoints[&#39;subscribers&#39;])
        except AttributeError:
            self.errored_attributes.append(&#34;endpoints&#34;)
            self.errored_attributes.append(&#34;posts&#34;)
            self.errored_attributes.append(&#34;subscriptions&#34;)
            self.errored_attributes.append(&#34;subscribers&#34;)

    def _data_cleaner(self, var):
        &#34;&#34;&#34;
        Cleans given data to make it uniform for the
        :param var:
        :return:
        &#34;&#34;&#34;
        # this returns a cleaned dict after striping the output it deems unneeded. Also only returns first object if given a list

        if type(var) == dict:
            if &#34;error&#34; in var and &#34;not_found&#34; == var[&#39;error&#39;]:
                raise NoContent()
            if &#34;id&#34; in var:
                return var
            elif &#34;data&#34; in var:
                if &#34;id&#34; in var[&#34;data&#34;]:
                    return var[&#34;data&#34;]
                return var[&#34;data&#34;][&#39;content&#39;][&#39;items&#39;][0]
        elif type(var) == list:
            return var[0]

        print(var)
        print(self.cdata)
        print(&#34;cleaner failed to find key&#34;)
        raise KeyError
    
    def reload(self):
        self.__init__(self.id)

    def add_post(self, thing):
        self.posts.store(thing)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ifunny_lib.User.add_post"><code class="name flex">
<span>def <span class="ident">add_post</span></span>(<span>self, thing)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_post(self, thing):
    self.posts.store(thing)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.User.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(self):
    self.__init__(self.id)</code></pre>
</details>
</dd>
<dt id="ifunny_lib.User.update_attributes"><code class="name flex">
<span>def <span class="ident">update_attributes</span></span>(<span>self, data:dict=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_attributes(self, data: dict = None):

    if not data:
        cdata = self.cdata
    else:
        cdata = self._data_cleaner(data)
        self.cdata = cdata

    self.errored_attributes = []

    try:
        self.days = cdata[&#34;meme_experience&#34;][&#34;days&#34;]
    except KeyError:
        self.errored_attributes.append(&#34;days&#34;)

    self.try_store_attribute(&#34;web_url&#34;, &#34;web_url&#34;)
    self.try_store_attribute(&#34;about&#34;, &#34;about&#34;)
    self.try_store_attribute(&#34;id&#34;, &#34;id&#34;)
    self.try_store_attribute(&#34;name&#34;, &#34;nick&#34;)
    self.try_store_attribute(&#34;stats&#34;, &#34;num&#34;)
    self.try_store_attribute(&#34;total_posts&#34;, &#34;total_posts&#34;)
    try:
        self.endpoints = {&#34;main&#34;: f&#34;https://api.ifunny.mobi/v4/account&#34;,
                          &#39;posts&#39;: f&#39;https://api.ifunny.mobi/v4/timelines/users/&#39; + self.id,
                          &#39;subscriptions&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscriptions&#34;,
                          &#39;subscribers&#39;: f&#34;https://api.ifunny.mobi/v4/users/{self.id}/subscribers&#34;}
        self.posts = Queue(Post, self.endpoints[&#39;posts&#39;])
        self.subscriptions = Queue(User, self.endpoints[&#39;subscriptions&#39;])
        self.subscribers = Queue(User, self.endpoints[&#39;subscribers&#39;])
    except AttributeError:
        self.errored_attributes.append(&#34;endpoints&#34;)
        self.errored_attributes.append(&#34;posts&#34;)
        self.errored_attributes.append(&#34;subscriptions&#34;)
        self.errored_attributes.append(&#34;subscribers&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></b></code>:
<ul class="hlist">
<li><code><a title="ifunny_lib.IfBase.load_data" href="#ifunny_lib.IfBase.load_data">load_data</a></code></li>
<li><code><a title="ifunny_lib.IfBase.load_file_full" href="#ifunny_lib.IfBase.load_file_full">load_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.store_file_full" href="#ifunny_lib.IfBase.store_file_full">store_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.try_store_attribute" href="#ifunny_lib.IfBase.try_store_attribute">try_store_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="ifunny_lib.api_call" href="#ifunny_lib.api_call">api_call</a></code></li>
<li><code><a title="ifunny_lib.dl_from_link" href="#ifunny_lib.dl_from_link">dl_from_link</a></code></li>
<li><code><a title="ifunny_lib.get_author_id" href="#ifunny_lib.get_author_id">get_author_id</a></code></li>
<li><code><a title="ifunny_lib.get_basic" href="#ifunny_lib.get_basic">get_basic</a></code></li>
<li><code><a title="ifunny_lib.get_bearer" href="#ifunny_lib.get_bearer">get_bearer</a></code></li>
<li><code><a title="ifunny_lib.get_collective" href="#ifunny_lib.get_collective">get_collective</a></code></li>
<li><code><a title="ifunny_lib.get_features" href="#ifunny_lib.get_features">get_features</a></code></li>
<li><code><a title="ifunny_lib.get_popular" href="#ifunny_lib.get_popular">get_popular</a></code></li>
<li><code><a title="ifunny_lib.kill_bearer" href="#ifunny_lib.kill_bearer">kill_bearer</a></code></li>
<li><code><a title="ifunny_lib.load_auths" href="#ifunny_lib.load_auths">load_auths</a></code></li>
<li><code><a title="ifunny_lib.post_from_id" href="#ifunny_lib.post_from_id">post_from_id</a></code></li>
<li><code><a title="ifunny_lib.post_from_url" href="#ifunny_lib.post_from_url">post_from_url</a></code></li>
<li><code><a title="ifunny_lib.recursive_id_print" href="#ifunny_lib.recursive_id_print">recursive_id_print</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ifunny_lib.Account" href="#ifunny_lib.Account">Account</a></code></h4>
<ul class="">
<li><code><a title="ifunny_lib.Account.reload" href="#ifunny_lib.Account.reload">reload</a></code></li>
<li><code><a title="ifunny_lib.Account.update_attributes" href="#ifunny_lib.Account.update_attributes">update_attributes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ifunny_lib.Comment" href="#ifunny_lib.Comment">Comment</a></code></h4>
<ul class="two-column">
<li><code><a title="ifunny_lib.Comment.add_reply" href="#ifunny_lib.Comment.add_reply">add_reply</a></code></li>
<li><code><a title="ifunny_lib.Comment.get_id_object" href="#ifunny_lib.Comment.get_id_object">get_id_object</a></code></li>
<li><code><a title="ifunny_lib.Comment.nest_replies" href="#ifunny_lib.Comment.nest_replies">nest_replies</a></code></li>
<li><code><a title="ifunny_lib.Comment.reload" href="#ifunny_lib.Comment.reload">reload</a></code></li>
<li><code><a title="ifunny_lib.Comment.tree_cdata" href="#ifunny_lib.Comment.tree_cdata">tree_cdata</a></code></li>
<li><code><a title="ifunny_lib.Comment.update_attributes" href="#ifunny_lib.Comment.update_attributes">update_attributes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ifunny_lib.IfBase" href="#ifunny_lib.IfBase">IfBase</a></code></h4>
<ul class="two-column">
<li><code><a title="ifunny_lib.IfBase.load_data" href="#ifunny_lib.IfBase.load_data">load_data</a></code></li>
<li><code><a title="ifunny_lib.IfBase.load_file" href="#ifunny_lib.IfBase.load_file">load_file</a></code></li>
<li><code><a title="ifunny_lib.IfBase.load_file_full" href="#ifunny_lib.IfBase.load_file_full">load_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.store_file" href="#ifunny_lib.IfBase.store_file">store_file</a></code></li>
<li><code><a title="ifunny_lib.IfBase.store_file_full" href="#ifunny_lib.IfBase.store_file_full">store_file_full</a></code></li>
<li><code><a title="ifunny_lib.IfBase.try_store_attribute" href="#ifunny_lib.IfBase.try_store_attribute">try_store_attribute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ifunny_lib.MissingAuthToken" href="#ifunny_lib.MissingAuthToken">MissingAuthToken</a></code></h4>
</li>
<li>
<h4><code><a title="ifunny_lib.NoContent" href="#ifunny_lib.NoContent">NoContent</a></code></h4>
</li>
<li>
<h4><code><a title="ifunny_lib.Post" href="#ifunny_lib.Post">Post</a></code></h4>
<ul class="two-column">
<li><code><a title="ifunny_lib.Post.add_comment" href="#ifunny_lib.Post.add_comment">add_comment</a></code></li>
<li><code><a title="ifunny_lib.Post.comment_tree" href="#ifunny_lib.Post.comment_tree">comment_tree</a></code></li>
<li><code><a title="ifunny_lib.Post.get_id_object" href="#ifunny_lib.Post.get_id_object">get_id_object</a></code></li>
<li><code><a title="ifunny_lib.Post.load_comment_tree" href="#ifunny_lib.Post.load_comment_tree">load_comment_tree</a></code></li>
<li><code><a title="ifunny_lib.Post.reload" href="#ifunny_lib.Post.reload">reload</a></code></li>
<li><code><a title="ifunny_lib.Post.update_attributes" href="#ifunny_lib.Post.update_attributes">update_attributes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ifunny_lib.Queue" href="#ifunny_lib.Queue">Queue</a></code></h4>
<ul class="two-column">
<li><code><a title="ifunny_lib.Queue.clear" href="#ifunny_lib.Queue.clear">clear</a></code></li>
<li><code><a title="ifunny_lib.Queue.load" href="#ifunny_lib.Queue.load">load</a></code></li>
<li><code><a title="ifunny_lib.Queue.load_from_file" href="#ifunny_lib.Queue.load_from_file">load_from_file</a></code></li>
<li><code><a title="ifunny_lib.Queue.load_next" href="#ifunny_lib.Queue.load_next">load_next</a></code></li>
<li><code><a title="ifunny_lib.Queue.load_until" href="#ifunny_lib.Queue.load_until">load_until</a></code></li>
<li><code><a title="ifunny_lib.Queue.page_info" href="#ifunny_lib.Queue.page_info">page_info</a></code></li>
<li><code><a title="ifunny_lib.Queue.queue_data_cleaner" href="#ifunny_lib.Queue.queue_data_cleaner">queue_data_cleaner</a></code></li>
<li><code><a title="ifunny_lib.Queue.save_to_file" href="#ifunny_lib.Queue.save_to_file">save_to_file</a></code></li>
<li><code><a title="ifunny_lib.Queue.store" href="#ifunny_lib.Queue.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ifunny_lib.Reply" href="#ifunny_lib.Reply">Reply</a></code></h4>
</li>
<li>
<h4><code><a title="ifunny_lib.User" href="#ifunny_lib.User">User</a></code></h4>
<ul class="">
<li><code><a title="ifunny_lib.User.add_post" href="#ifunny_lib.User.add_post">add_post</a></code></li>
<li><code><a title="ifunny_lib.User.reload" href="#ifunny_lib.User.reload">reload</a></code></li>
<li><code><a title="ifunny_lib.User.update_attributes" href="#ifunny_lib.User.update_attributes">update_attributes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>